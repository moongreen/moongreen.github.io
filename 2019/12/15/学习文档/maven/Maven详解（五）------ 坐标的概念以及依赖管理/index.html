<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Maven详解（五）—— 坐标的概念以及依赖管理　　我们知道maven能帮我们管理jar包，那么它是怎么管理的呢？这篇博客我们来详细介绍。 1、什么是坐标？　　①、数学中的坐标 　　　　在平面上，使用 X 、Y 两个向量可以唯一的定位平面中的任何一个点 　　　　在空间中，使用 X、Y、Z 三个向量可以唯一的定位空间中的任意一个点 　　②、Maven 中的坐标 　　　　俗称 gav：使用下面三个向量">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/2019/12/15/学习文档/maven/Maven详解（五）------ 坐标的概念以及依赖管理/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Maven详解（五）—— 坐标的概念以及依赖管理　　我们知道maven能帮我们管理jar包，那么它是怎么管理的呢？这篇博客我们来详细介绍。 1、什么是坐标？　　①、数学中的坐标 　　　　在平面上，使用 X 、Y 两个向量可以唯一的定位平面中的任何一个点 　　　　在空间中，使用 X、Y、Z 三个向量可以唯一的定位空间中的任意一个点 　　②、Maven 中的坐标 　　　　俗称 gav：使用下面三个向量">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830211037062-128803329.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830212535468-1450740064.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830221620890-18460703.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830222649546-517820136.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830222955749-692178369.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830223058624-1830235216.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830223230562-63445240.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830223353874-95793758.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830224603343-1515782308.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830232214140-802764608.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830233009280-1582726667.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830233151749-1645068897.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830233238733-165096030.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830233708171-340184405.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830233829358-52202347.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830234858296-826245551.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830235311890-363021832.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830235124733-1739762397.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830235223780-459002277.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170831000230046-2116609529.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170831000829515-1993242804.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170831000856249-163663194.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170831001250499-1078223970.png">
<meta property="og:updated_time" content="2019-11-29T03:36:16.726Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="Maven详解（五）—— 坐标的概念以及依赖管理　　我们知道maven能帮我们管理jar包，那么它是怎么管理的呢？这篇博客我们来详细介绍。 1、什么是坐标？　　①、数学中的坐标 　　　　在平面上，使用 X 、Y 两个向量可以唯一的定位平面中的任何一个点 　　　　在空间中，使用 X、Y、Z 三个向量可以唯一的定位空间中的任意一个点 　　②、Maven 中的坐标 　　　　俗称 gav：使用下面三个向量">
<meta name="twitter:image" content="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830211037062-128803329.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-学习文档/maven/Maven详解（五）------ 坐标的概念以及依赖管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/15/学习文档/maven/Maven详解（五）------ 坐标的概念以及依赖管理/" class="article-date">
  <time datetime="2019-12-15T05:32:17.100Z" itemprop="datePublished">2019-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Maven详解（五）——-坐标的概念以及依赖管理"><a href="#Maven详解（五）——-坐标的概念以及依赖管理" class="headerlink" title="Maven详解（五）—— 坐标的概念以及依赖管理"></a><a href="https://www.cnblogs.com/ysocean/p/7451054.html" target="_blank" rel="noopener">Maven详解（五）—— 坐标的概念以及依赖管理</a></h1><p>　　我们知道maven能帮我们管理jar包，那么它是怎么管理的呢？这篇博客我们来详细介绍。</p>
<h3 id="1、什么是坐标？"><a href="#1、什么是坐标？" class="headerlink" title="1、什么是坐标？"></a>1、什么是坐标？</h3><p>　　<strong>①、数学中的坐标</strong></p>
<p>　　　　在平面上，使用 X 、Y 两个向量可以唯一的定位平面中的任何一个点</p>
<p>　　　　在空间中，使用 X、Y、Z 三个向量可以唯一的定位空间中的任意一个点</p>
<p>　　<strong>②、Maven 中的坐标</strong></p>
<p>　　　　俗称 gav：使用下面三个向量子仓库中唯一定位一个 Maven 工程</p>
<p>　　　　在项目中的 pom.xml 文件中，我们可以看到下面gav的定义：</p>
<p>　　　　1、groupid:公司或组织域名倒序 </p>
<p>　　　　　　<groupid>com.ys.maven</groupid></p>
<p>　　　　2、artifactid:模块名，也是实际项目的名称</p>
<p>　　　　　　<artifactid>Maven_05</artifactid></p>
<p>　　　　3、version:当前项目的版本</p>
<p>　　　　　　<version>0.0.1-SNAPSHOT</version></p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830211037062-128803329.png" alt="img"></p>
<p>　　<strong>③、Maven 坐标和仓库，jar 包的关系</strong></p>
<p>　　　　什么是仓库，后面我们会详细讲解，现在你只需要知道是Maven 用来存放 jar 包的地方。</p>
<p>　　　　那么依照上面定义的 gav，我们执行 mvn -install 命令，会出现什么情况呢？</p>
<p>　　　　首先进入到我们第二篇博客 <a href="http://www.cnblogs.com/ysocean/p/6725729.html" target="_blank" rel="noopener">Maven 的安装配置</a> ，通过 settings.xml 文件配置的仓库目录。</p>
<p>　　　　　　将我们上面配置的 gav 向量组合起来就是目录：</p>
<p>　　　　　　com/ys/maven/Maven_05/0.0.1-SNAPSHOT/Maven_05-0.0.1-SNAPSHOT.jar</p>
<p> 　　　　　　<img src="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830212535468-1450740064.png" alt="img"></p>
<p>　　　　其次，我们观察打出来的 jar 包：</p>
<p>　　　　　　Maven_05-0.0.1-SNAPSHOT.jar</p>
<p>　　　　也就是 artifactid-version.jar</p>
<h3 id="2、什么是依赖？"><a href="#2、什么是依赖？" class="headerlink" title="2、什么是依赖？"></a>2、什么是依赖？</h3><p> 　　什么是 依赖？相信有过一定开发经验的人知道，每当我们需要使用某个框架时，比如 SpringMVC，那么我们需要导入相应的 jar 包，但是手动导入包的时候，往往会漏掉几个 jar 包，那么在使用该框架的时候系统就会报错。那么我们就说导入的包与未导入的包存在依赖关系。而使用 Maven,我们只需要在 pom.xml 文件中进行相应的配置，它就会帮助我们自动管理 jar 包之间的依赖关系。那么它是怎么管理的呢，接下来我们会详细讲解。</p>
<h3 id="3、依赖的详细配置"><a href="#3、依赖的详细配置" class="headerlink" title="3、依赖的详细配置"></a>3、依赖的详细配置</h3><p>　　我们以 Junit 为例，在 pom.xml 文件中进行详细而完整的配置。　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;project&gt;      </span><br><span class="line">    &lt;dependencies&gt; </span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;      </span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;      </span><br><span class="line">            &lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;...&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;...&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;...&lt;/optional&gt;</span><br><span class="line">            &lt;exclusions&gt;      </span><br><span class="line">                &lt;exclusion&gt;      </span><br><span class="line">                  &lt;groupId&gt;...&lt;/groupId&gt;      </span><br><span class="line">                  &lt;artifactId&gt;...&lt;/artifactId&gt;      </span><br><span class="line">                &lt;/exclusion&gt; </span><br><span class="line">          &lt;/exclusions&gt;      </span><br><span class="line">        &lt;/dependency&gt;         </span><br><span class="line">      &lt;/dependencies&gt;      </span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<p>　　①、dependencies：一个 pom.xml 文件中只能存在一个这样的标签。用来管理依赖的总标签。</p>
<p>　　②、dependency:包含在dependencies标签中，可以有无数个，每一个表示一个依赖</p>
<p>　　③、groupId,artifactId和version：依赖的基本坐标，对于任何一个依赖来说，基本坐标是最重要的，Maven根据坐标才能找到需要的依赖。</p>
<p>　　④、type：依赖的类型，对应于项目坐标定义的packaging。大部分情况下，该元素不必声明，其默认值是jar。</p>
<p>　　⑤、scope：依赖的范围，默认值是 compile。后面会进行详解。</p>
<p>　　⑥、optional：标记依赖是否可选。</p>
<p>　　⑦、exclusions：用来排除传递性依赖，后面会进行详细介绍。</p>
<p>　　</p>
<h3 id="4、依赖的范围-scope"><a href="#4、依赖的范围-scope" class="headerlink" title="4、依赖的范围 scope"></a>4、依赖的范围 scope</h3><p> 　　<img src="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830221620890-18460703.png" alt="img"></p>
<p>　　一般情况下，我们对前面三个依赖用的比较多。下面的主程序表示maven 目录结构 src/main/java.测试程序目录结构为：src/test/java</p>
<p> 　　<strong>1、compile 范围依赖</strong></p>
<p>　　　　对主程序是否有效：有效</p>
<p>　　　　对测试程序是否有效：有效</p>
<p>　　　　是否参与打包：参与</p>
<p>　　　　是否参与部署：参与</p>
<p>　　　　典型例子：log4j</p>
<p>　　　　</p>
<p>　　<strong>2、test 范围依赖</strong></p>
<p>　　　　对主程序是否有效：无效</p>
<p>　　　　对测试程序是否有效：有效</p>
<p>　　　　是否参与打包：不参与</p>
<p>　　　　是否参与部署：不参与</p>
<p>　　　　典型例子：Junit</p>
<p>　　</p>
<p>　　<strong>3、provided 范围依赖</strong></p>
<p>　　　　对主程序是否有效：有效</p>
<p>　　　　对测试程序是否有效：有效</p>
<p>　　　　是否参与打包：不参与</p>
<p>　　　　是否参与部署：不参与</p>
<p>　　　　典型例子：servlet-api.jar，一般在发布到 服务器中，比如 tomcat，服务器会自带 servlet-api.jar 包，所以provided 范围依赖只在编译测试有效。</p>
<p>　　　 </p>
<p> 　　<strong>4、runtime 范围依赖</strong>：在测试、运行的时候依赖，在编译的时候不依赖。例如：JDBC驱动，项目代码只需要jdk提供的jdbc接口，只有在执行测试和运行项目的时候才需要实现jdbc的功能。</p>
<p> 　　</p>
<p> 　　接下来我们举几个例子在工程中实际去理解：</p>
<p>　　　　<strong>test 依赖和 compile 依赖的区别：</strong></p>
<p>　　　　①、首先我们在 pom.xml 文件中配置，Junit 的 test 依赖</p>
<p> 　　　　　　<img src="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830222649546-517820136.png" alt="img"></p>
<p>　　　　②、我们在主程序中去导入 Junit 的包，然后进行 mvn -compile 编译，很明显，test 范围的在主程序中无效，故编译会报错。</p>
<p>　　　　　　我们在 src/main/java 包下新建 MavenTest.java,并导入 Junit 包</p>
<p>　　　　　　<img src="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830222955749-692178369.png" alt="img"></p>
<p>　　　　　　然后执行 mvn -compile 操作，如下图报错信息：</p>
<p><img src="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830223058624-1830235216.png" alt="img"></p>
<p>　　　　③、我们将 Junit 的依赖范围改为 compile，然后执行 mvn -compile</p>
<p>　　　　　　<img src="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830223230562-63445240.png" alt="img"></p>
<p>　　　　　　发现 mvn -compile 没有报错了。</p>
<p>　　　　　　<img src="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830223353874-95793758.png" alt="img"></p>
<h3 id="4、依赖的传递"><a href="#4、依赖的传递" class="headerlink" title="4、依赖的传递"></a>4、依赖的传递</h3><p>　　比如我们创建三个Maven 工程，maven-first,maven-second以及maven-third,而third依赖于second，second又依赖于first，那么我们说 second 是 third 的第一直接依赖，first是second的第二直接依赖。而first是third的间接依赖。</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830224603343-1515782308.png" alt="img"></p>
<p> 　　依赖之间的传递如下图：<strong>第一列表示第一直接依赖，第一行表示第二直接依赖</strong></p>
<p>　　<img src="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830232214140-802764608.png" alt="img"></p>
<p>　　<strong>总结：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、当第二依赖的范围是compile的时候，传递性依赖的范围与第一直接依赖的范围一致。</span><br><span class="line">2、当第二直接依赖的范围是test的时候，依赖不会得以传递。</span><br><span class="line">3、当第二依赖的范围是provided的时候，只传递第一直接依赖范围也为provided的依赖，且传递性依赖的范围同样为 provided；</span><br><span class="line">4、当第二直接依赖的范围是runtime的时候，传递性依赖的范围与第一直接依赖的范围一致，但compile例外，此时传递的依赖范围为runtime；</span><br></pre></td></tr></table></figure>

<p>　　我们这里举个例子来看：</p>
<p>　　①、第二依赖范围是 test</p>
<p>　　　　Maven_first 的pom.xml 文件如下：</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830233009280-1582726667.png" alt="img"></p>
<p>　　　　然后Maven_second依赖Maven_fisrt,Maven_third依赖Maven-second,其pom.xml 文件如下：</p>
<p>　　　　Maven_second的 pom.xml</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830233151749-1645068897.png" alt="img"></p>
<p>　　　　</p>
<p>　　　　Maven_third的 pom.xml</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830233238733-165096030.png" alt="img"></p>
<p>　　　　我们发现在 Maven_third和 Maven_second 都没有 Maven_first 引入的 Junit 包，正好符合上面总结的第二点：当第二直接依赖的范围是test的时候，依赖不会得以传递。</p>
<p> 　　　　<img src="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830233708171-340184405.png" alt="img"></p>
<p> 　　　　②、第二依赖范围是 compile</p>
<p> 　　　　如果我们将 Maven_first 的Junit 改为 compile，那么将会符合上面总结的第一点：当第二依赖的范围是compile的时候，传递性依赖的范围与第一直接依赖的范围一致。</p>
<p> 　　　　　<img src="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830233829358-52202347.png" alt="img"></p>
<h3 id="5、依赖的排除"><a href="#5、依赖的排除" class="headerlink" title="5、依赖的排除"></a>5、依赖的排除</h3><p>　　如果我们在当前工程中引入了一个依赖是 A，而 A 又依赖了 B，那么 Maven 会自动将 A 依赖的 B 引入当前工程，但是个别情况下 B 有可能是一个不稳定版，或对当前工程有不良影响。这时我们可以在引入 A 的时候将 B 排除。</p>
<p>　　比如：我们在Maven_first 中添加 spring-core,maven 会自动将 commons-logging添加进来，那么由于 Maven_second 是依赖 Maven_first  的，那么 Maven_second  中将存在 spring-core(自带了commons-logging)，这时候我们不想要 commons-logging，那该怎么办呢？我们上面第二大点提到了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exclusions：用来排除传递性依赖</span><br></pre></td></tr></table></figure>

<p>　　Maven_first 的 pom.xml 文件</p>
<p><img src="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830234858296-826245551.png" alt="img"></p>
<p>　　由于 Maven_second 依赖 Maven_second，故Maven_second 存在 spring-core 包</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830235311890-363021832.png" alt="img"></p>
<p> 　　如何排除呢？我们在 Maven_second 的 pom.xml 文件中添加如下代码：</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830235124733-1739762397.png" alt="img"></p>
<p>　　再次查看工程：Maven_second 的 commons-logging 已经移除了</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170830235223780-459002277.png" alt="img"></p>
<h3 id="6、依赖的冲突"><a href="#6、依赖的冲突" class="headerlink" title="6、依赖的冲突"></a>6、依赖的冲突</h3><p>　　在maven中存在两种冲突方式：一种是跨pom文件的冲突，一致是同一个pom文件中的冲突。</p>
<p>　　<strong>①、跨 pom 文件，路径最短者优先。</strong>比如我们在 Maven_first 中的 Junit 是4.9版本的，Maven_second 中的 Junit 是4.8版本的，那么Maven_third 中的 Junit 将会是那个版本呢？</p>
<p>　　　　<img src="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170831000230046-2116609529.png" alt="img"></p>
<p>　　由上图我们可以看出，由于 Maven_second 是 Maven_third 的直接依赖，明显相比于 Maven_first 路径要短，所以 Maven_third 的 Junit 版本与 Maven_second 保持一致。</p>
<p>　　<strong>②、同一个pom.xml 文件，先申明者优先。</strong></p>
<p>　　<img src="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170831000829515-1993242804.png" alt="img"></p>
<p>　　</p>
<p>　　<strong>看 Maven_second</strong></p>
<p>　　<img src="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170831000856249-163663194.png" alt="img"></p>
<h3 id="7、可选依赖"><a href="#7、可选依赖" class="headerlink" title="7、可选依赖"></a>7、可选依赖</h3><p>　　Optional标签标示该依赖是否可选，默认是false。可以理解为，如果为true，则表示该依赖不会传递下去，如果为false，则会传递下去。</p>
<p> 　　<img src="https://images2017.cnblogs.com/blog/1120165/201708/1120165-20170831001250499-1078223970.png" alt="img"></p>
<p>　　我们是在 Maven_second 的 pom 文件中设定 Junit 不可传递，那么Maven_third 工程中将不会有来自 Maven_second 的 Junit 的传递。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/15/学习文档/maven/Maven详解（五）------ 坐标的概念以及依赖管理/" data-id="ck46kswf3000964ss141wn17x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/12/15/学习文档/MQ/ActiveMQ/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2019/12/15/学习文档/maven/maven基础知识/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/12/15/raids/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/12/15/学习文档/项目管理/github/github学习/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/12/15/学习文档/项目管理/git/idea-git配置/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/12/15/学习文档/项目管理/git/git学习文档/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/12/15/学习文档/框架/SOA架构和微服务架构的区别/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>