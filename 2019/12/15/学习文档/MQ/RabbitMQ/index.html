<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="第一章 主流消息中间件介绍-activeMQ  第二章初识 RabbitMORabbitMQ是一个开源的消息代理和队列服务器,用来通过普通协议在完全不同的应用之间共享数据, RabbitMQ是使用 Erlang语言来编写的,并且 Rabbits是基于AMQP协议的 （跨平台、跨语言） 哪些大厂在用 RabbitMO,为什么?滴滴、美团、头条、去哪儿、艺龙开源、性能优秀,稳定性保障提供可靠性消息投递">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="第一章 主流消息中间件介绍-activeMQ  第二章初识 RabbitMORabbitMQ是一个开源的消息代理和队列服务器,用来通过普通协议在完全不同的应用之间共享数据, RabbitMQ是使用 Erlang语言来编写的,并且 Rabbits是基于AMQP协议的 （跨平台、跨语言） 哪些大厂在用 RabbitMO,为什么?滴滴、美团、头条、去哪儿、艺龙开源、性能优秀,稳定性保障提供可靠性消息投递">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C32.png">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C33.png">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C34.png">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C35.png">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C36.png">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C37.png">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C39.png">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C38.png">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C2.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C3.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C4.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C5.png">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C6.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C7.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C8.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C9.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C10.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C11.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C12.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C13.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C14.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C15.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C16.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C17.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C18.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C19.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C20.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C21.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C22.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C23.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images/RabbitMQ/24.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images/RabbitMQ/25.png">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C26.png">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C27.png">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C28.png">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C29.png">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C30.png">
<meta property="og:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C31.png">
<meta property="og:updated_time" content="2019-12-14T11:51:06.643Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="第一章 主流消息中间件介绍-activeMQ  第二章初识 RabbitMORabbitMQ是一个开源的消息代理和队列服务器,用来通过普通协议在完全不同的应用之间共享数据, RabbitMQ是使用 Erlang语言来编写的,并且 Rabbits是基于AMQP协议的 （跨平台、跨语言） 哪些大厂在用 RabbitMO,为什么?滴滴、美团、头条、去哪儿、艺龙开源、性能优秀,稳定性保障提供可靠性消息投递">
<meta name="twitter:image" content="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/images%5CRabbitMQ%5C32.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-学习文档/MQ/RabbitMQ" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/15/学习文档/MQ/RabbitMQ/" class="article-date">
  <time datetime="2019-12-15T05:32:17.261Z" itemprop="datePublished">2019-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>第一章</p>
<p>主流消息中间件介绍-activeMQ</p>
<p><img src="images%5CRabbitMQ%5C32.png" alt="32"></p>
<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><p>初识 RabbitMO<br>RabbitMQ是一个开源的消息代理和队列服务器,用来通过普通协议<br>在完全不同的应用之间共享数据, RabbitMQ是使用 Erlang语言来编写<br>的,并且 Rabbits是基于AMQP协议的</p>
<p>（跨平台、跨语言）</p>
<h5 id="哪些大厂在用-RabbitMO-为什么"><a href="#哪些大厂在用-RabbitMO-为什么" class="headerlink" title="哪些大厂在用 RabbitMO,为什么?"></a>哪些大厂在用 RabbitMO,为什么?</h5><p>滴滴、美团、头条、去哪儿、艺龙<br>开源、性能优秀,稳定性保障<br>提供可靠性消息投递模式( confirm)、返回模式( return)</p>
<h5 id="哪些大厂在用-RabbitMO-为什么-1"><a href="#哪些大厂在用-RabbitMO-为什么-1" class="headerlink" title="哪些大厂在用 RabbitMO,为什么?"></a>哪些大厂在用 RabbitMO,为什么?</h5><p>与 SpringAMQP完美的整合、AP丰富<br>集群模式丰富,表达式配置,HA模式（实现高可用）,镜像队列模型<br>保证数据不丢失的前提做到高可靠性、可用性</p>
<p>RabbitMO高性能的原因?</p>
<h5 id="√-Erlang语言最初在于交换机领域的架构模式-这样使得"><a href="#√-Erlang语言最初在于交换机领域的架构模式-这样使得" class="headerlink" title="√ Erlang语言最初在于交换机领域的架构模式,这样使得"></a>√ Erlang语言最初在于交换机领域的架构模式,这样使得</h5><p>RabbitMO在 Broker之间进行数据交互的性能是非常优秀的<br>√ Erlang的优点: Erlang有着和原生 Socket一样的延迟</p>
<p>什么是AMQP高级消息队列协议?</p>
<h5 id="√AMQP全称-Advanced-Message-Queuing-Protocol"><a href="#√AMQP全称-Advanced-Message-Queuing-Protocol" class="headerlink" title="√AMQP全称: Advanced Message Queuing Protocol"></a>√AMQP全称: Advanced Message Queuing Protocol</h5><p>√AMQP翻译:高级消息队列协议</p>
<p>什么是AMQP高级消息队列协议?<br>AMQP定义:是具有现代特征的二进制协议。是一个提供统一消息<br>服务的应用层标准高级消息队列协议,是应用层协议的—个开放标<br>准,为面向消息的中间件设计。</p>
<p><img src="images%5CRabbitMQ%5C33.png" alt="33"></p>
<p>导航</p>
<p>1、互联网大厂为什么选择rabbitMq、</p>
<p>2、rabbitMq的高性能之道</p>
<p>3、什么是amqp高级协议</p>
<p>4、amqp核心概念是什么</p>
<p>5、rabbitmq整体架构模型是什么样子的</p>
<p>6、rabbitmq消息是如何流转的</p>
<p>7、rabbitmq安装与使用</p>
<p>8、命令行与管控台</p>
<p>9、rabbitmq消息生成与消费</p>
<p>10、rabbitmq交换机详解</p>
<p>11、rabbitmq队列、绑定、虚拟主机、消息</p>
<p>MQP核心概念<br>Server:又称 Broker,接受客户端的连接,实现AMQP实体服务」<br>Connection:连接,应用程序与 Broker的网络连接</p>
<p>AMQP核心概念<br>Channel:网络信道,几乎所有的操作都在 Channel中进行, Channel<br>是进行消息读写的通道。客户端可建立多个 Channe,每个 Channe代<br>表一个会话任务。</p>
<p>AMQP核心概念<br>Message:消息,服务器和应用程序之间传送的数据,由 Properties<br>和Body组成。 Properties可以对消息进行修饰,比如消息的优先级<br>延迟等高级特性;Body则就是消息体内容。</p>
<p>AMQP核心概念<br>Virtual host:虚拟地址,用于进行逻辑隔离,最上层的消息路由。<br>Virtual Host里面可以有若干个 Exchange和 Queue,同一个 Virtua<br>Host里面不能有相同名称的 Exchange或 Queue</p>
<p>Exchange:交换机,接收消息,根据路由键转发消息到绑定的队列</p>
<p>AMQP核心概念<br>Binding: Exchange和 Queue之间的虚拟连接, binding中可以包含 routing key<br>Routing key:一个路由规则,虛拟机可用它来确定如何路由一个特定消息<br>Queue:也称为 Message Queue,消息队列,保存消息并将它们转发给消费者<img src="images%5CRabbitMQ%5C34.png" alt="34"></p>
<p><img src="images%5CRabbitMQ%5C35.png" alt="35"></p>
<p>安装：</p>
<p>1、rabbitmq与Erlang语言相对应</p>
<p>默认端口号5672</p>
<p>RabbitMO安装与使用<br>服务的启动: rabbitmq- server start&amp;<br>服务的停止: rabbitmgctl stop app<br>管理插件: rabbitmq-plugins enable rabbitmq management<br>访问地址:htp//192168.1176:15672</p>
<p>命令行与管控台-基础操作<br>rabbitmgctl stop app:关闭应用<br>rabbitmgctl start app:启动应用<br>rabbitmgctl status:节点状态</p>
<p>命令行与管控台-基础操作<br>rabbitmgctl add user username password:添加用户<br>rabbitmqctl list users:列出所有用户<br>rabbitmgctl delete user username:删除用户<br>rabbitmgctl clear permissions-p vhostpath username清除用户权限</p>
<p>命令行与管控台-基础操作<br>rabbitmactl list user permissions username:列出用户权限<br>rabbitmgctl change password username newpassword:修改密码<br>rabbitmqctl set permissions-p vhostpath username “*.” “*.” “*.”:设置用户权限</p>
<p>命令行与管控台-基础操作<br>rabbitmqctl add vhost vhostpath:创建虚拟主机<br>rabbitmgctl list vhosts:列出所有虚拟主机<br>rabbitmactl list permissions- p vhostpath:列出虚拟主机上所有权限<br>rabbitmqctl delete vhost vhostpath:删除虚拟主机</p>
<p>命令行与管控台-基础操作<br>V rabbitmqctl list queues:查看所有队列信息<br>v rabbitmgctl- p vhostpath purge queue blue:清除队列里的消息</p>
<p>命令行与管控台高级操作<br>rabbitmgctl reset:移除所有数据,要在 rabbitmgctl stop app之后使用<br>rabbitmqctl join cluster&lt; clusternode&gt;[-ram:组成集群命令<br>rabbitmactl cluster status:查看集群状态</p>
<p>命令行与管控台-高级操作<br>rabbitmgctl change cluster node type disc ram<br>修改集群节点的存储形式<br>rabbitmgctl forget cluster node- offline忘记节点(摘除节点</p>
<p>rabbitmgctl rename cluster node oldnode1 newnode 1 [oldnode2]<br>[newnode2…](修改节点名称)</p>
<p>rabbitmgctl list queues:查看所有队列信息<br>rabbitmgctl- p vhostpath purge queue blue:清除队列里的消息</p>
<p>急速入门-消息生产与消费<br>ConnectionFactory:获取连接工厂(new 同时设置host、port、virtualHost、usename、password)</p>
<p>Connection:一个连接(factory.newConnection())</p>
<p>Channel:数据通信信道,可发送和接收消息（connction.createChannel()）</p>
<p>Queue:具体的消息存储队列</p>
<p>Producer&amp; Consumer生产和消费者</p>
<p>发送消息channel.basicPublish(exchagename(如果为“”则表示默认路由:direct),routekey,props,body);</p>
<h5 id="消费端："><a href="#消费端：" class="headerlink" title="消费端："></a>消费端：</h5><p>1、创建channel</p>
<p>2、声明对列（如果存在则直接返回、否则新建）</p>
<p>channel.queueDeclare(queuename(队列名称),durable（是否持久化）,exlusive（是否排他队列）,autoDelete（自动删除）,arguments（扩展参数Map）);</p>
<p>3、创建消费者</p>
<p>QueueingConsumer quereConsumer = new QueueingConsumer(channel);</p>
<p>4、设置Channel</p>
<p>channel.basicConsume(queuename(队列名称)，autoAck(确认模式：是否自动签收),callback(异步处理消息的方法 quereConsumer )）；</p>
<p><strong>5、获取消息（while）</strong></p>
<p>（一）Delivery delivery = queueConsumer.nextDelivery();//没有消息时会一直阻塞队列   nextDeliveryLong();//阻塞时间</p>
<p>delivery .getBody();//消息体</p>
<p>Envelope envelope = delivery.getEnvelope();//重要的信息</p>
<p>envelope .getDeliveryTag();//</p>
<p>（二）获取消息异步处理 extends DefaultConsumer</p>
<p>实现public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException </p>
<h4 id="Exchange交换机"><a href="#Exchange交换机" class="headerlink" title="Exchange交换机"></a>Exchange交换机</h4><p><img src="images%5CRabbitMQ%5C36.png" alt="36"></p>
<p>交换机属性<br>Name:交换机名称<br>Type:交换机类型 direct（直连型）、 topIc、 fanout、 headers、（system、自定义）</p>
<p>Durability:是否需要持久化,true为持久化</p>
<p>交换机属性<br>Auto delete:当最后一个绑定到 Exchange上的队列删除后,自动删除该 Exchange<br>nternal:当前 Exchange是否用于 RabbitS内部使用,默认为False<br>Arguments:扩展参数,用于扩展AMQP协议自制定化使用</p>
<h5 id="一、Direct-Exchange（直连型路由）"><a href="#一、Direct-Exchange（直连型路由）" class="headerlink" title="一、Direct Exchange（直连型路由）"></a>一、Direct Exchange（直连型路由）</h5><p>所有发送到 Direct Exchange的消息被转发到 RouteKey中指定的 Queue<br>注意: Directi模式可以使用 RabbitMQ自带的 Exchange: default<br>Exchange,所以不需要将 Exchange进行任何绑定( binding)操作,消息传<br>递时, Routekey必须完全匹配才会被队列接收,否则该消息会被抛弃</p>
<h5 id="路由："><a href="#路由：" class="headerlink" title="路由："></a>路由：</h5><p>1、获取channel</p>
<p>2、声明</p>
<p>channel.exchangeDeclare(exchangename(路由器名称),exchangetype（路由器类型）, durable（是否持久化）,autoDelete（是否自动删除）,internal（是否用于 RabbitS内部使用）,artuments（扩展参数）)</p>
<p>3、绑定路由和queue（可以绑多个）</p>
<p>channel.queueBind(queuename,exchangename,routingkey);//持久化路由只能有持久化队列绑定，否则抛出异常</p>
<p><img src="images%5CRabbitMQ%5C37.png" alt="37"></p>
<p>三、Fanout Exchange（广播型）<br>不处理路由键,只需要简单的将队列绑定到交换机上<br>发送到交换机的消息都会被转发到与该交换机绑定的所有队列上<br>Fanout交换机转发消息是最快的</p>
<p><img src="images%5CRabbitMQ%5C39.png" alt="39"></p>
<h5 id="二、Topic-Exchange（主题型路由）"><a href="#二、Topic-Exchange（主题型路由）" class="headerlink" title="二、Topic Exchange（主题型路由）"></a>二、Topic Exchange（主题型路由）</h5><p>所有发送到 Topic Exchange的消息被转发到所有关心 Routekey中指<br>定 Topic的 Queue上<br>Exchange将 RouteKey和某 Topic进行模糊匹配<br>此时队列需要绑定一个 Topic</p>
<p>Topic Exchange</p>
<p>注意:可以使用通配符进行模糊匹配<br>符号“#”匹配一个或多个词<br>符号“*”匹配不多不少一个词<br>例如:“log.#”能够匹配到” log. info.oa”<br>“log.*”只会匹配到” log.erro</p>
<p><img src="images%5CRabbitMQ%5C38.png" alt="38"></p>
<p>Binding-绑定（过个路由也可以绑定：且消息会传递）<br>Exchange和 Exchange、 Queue之间的连接关系<br>Binding中可以包含 RoutingKeyi或者参数</p>
<p>Queue-消息队列<br>消息队列,实际存储消息数据<br>Durability:是否持久化, Durable:是, Transient:否<br>Auto delete:如选yes,代表当最后一个监听被移除之后,<br>该 Queue会自动被删除</p>
<p>Message-消息<br>服务器和应用程序之间传送的数据<br>本质上就是一段数据,由 Properties和 Payload(Body)组成<br>常用属性: delivery_mode(1、非持久化，2、持久化)、 headers(自定义属性Map)</p>
<p>Message-其他属性<br>content-type、 content-encoding、 priority（优先级0-9）<br>correlation_id、 reply _to(返回队列)、 expiration（过期时间）、 message_id<br>timestamp、type、 user_id、 app_id、 cluster_id</p>
<h3 id="获取basic-properties"><a href="#获取basic-properties" class="headerlink" title="获取basic.properties:"></a>获取basic.properties:</h3><p>AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder().deliveryMode(2)…build();</p>
<p>Virtual host虚拟主机<br>虚拟地址,用于进行逻辑隔离,最上层的消息路由<br>一个 Virtual Host里面可以有若干个 Exchange和 Queue<br>同一个 Virtual Host里面不能有相同名称的 Exchange或 Queue</p>
<h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><p>消息如何保障100%的投递成功？</p>
<p>幂等性概念详解？</p>
<p>在海量订单产生的业务高峰期，如何避免消息的重复消费问题？</p>
<p>confirm确认消息、return返回消息？</p>
<h3 id="本章导航"><a href="#本章导航" class="headerlink" title="本章导航"></a>本章导航</h3><p>自定义消费者</p>
<p>消息的ACK与重回队列</p>
<p>消息的限流</p>
<p>TTL消息</p>
<p>死信队列</p>
<h3 id="消息如何保障100-的投递成功？"><a href="#消息如何保障100-的投递成功？" class="headerlink" title="消息如何保障100%的投递成功？"></a>消息如何保障100%的投递成功？</h3><p>一、什么是生产端的可靠性投递</p>
<p>​    1、保障消息的成功发出</p>
<p>​    2、保障MQ节点的成功接收</p>
<p>​    3、发送端收到MQ节点（BROKER）确认应答</p>
<p>​    4、完善的消息进行补偿机制</p>
<p>生产端-可靠性投递（一）</p>
<p>BAT/TMD互联网大厂的解决法案</p>
<p>​    消息落库，对消息状态进行打标。</p>
<p>​    消息的延迟投递、做二次确认，回调检查。</p>
<p>生产端-可靠性投递（二）</p>
<p><img src="images%5CRabbitMQ%5C2.jpg" alt="2"></p>
<p>生产端-可靠性投递（三）</p>
<p>保障MQ我们思考第一种可靠性投递，在高并发的场景下是否合适？</p>
<p>消息的延迟投递，做二次确认，回调检查。</p>
<p>生产端-可靠性投递（四）</p>
<p><img src="images%5CRabbitMQ%5C3.jpg" alt="3"></p>
<h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><p>我们可以借鉴数据库的乐观锁机制</p>
<p>比如我们执行一条更新库存的SQL语句</p>
<p>update table set count = count -1,version = vesion + 1 where version = 1</p>
<p>消费端-幂等性保障</p>
<p>在海量订单产生的业务高峰期，如何避免消息的消费问题？</p>
<p>业界主流的幂等性操作：</p>
<p>​    唯一ID+指纹码机制，利用数据库主键去重</p>
<p>​        唯一ID+指纹码机制，利用数据库主键去重</p>
<p>​        select count(1) from table  where ID = 唯一ID+指纹码</p>
<p>​        好处：实现简单</p>
<p>​        坏处：高并发下有数据写入的性能瓶颈</p>
<p>​        解决方案：跟进ID进行分库分表进行算法路由 </p>
<p>​    利用Redis的原子性去实现</p>
<p>​        使用Redis进行幂等、需要考虑的问题</p>
<p>​        第一：我们是否要进行数据落库，如果落库的话，关键解决的问题是数据库和缓存如何做到原子性</p>
<p>​        第二：如果不行落库，那么都储存到缓存中，如何设置定时同步的策略？</p>
<h3 id="confirm确认消息"><a href="#confirm确认消息" class="headerlink" title="confirm确认消息"></a>confirm确认消息</h3><p>理解confirm消息确认机制：</p>
<p>消息的确认，是指生产者投递消息后，如果Broker收到消息，则会给我们生产者一个应答。</p>
<p>生产者进行接收应答，用来确定这条消息是否正常的发送到Broker，这种方式也是消息的可靠性投递的核心保障！</p>
<p><img src="images%5CRabbitMQ%5C4.jpg" alt="4"></p>
<h3 id="confirm确认消息实现"><a href="#confirm确认消息实现" class="headerlink" title="confirm确认消息实现"></a>confirm确认消息实现</h3><p>如何实现confirm确认消息？</p>
<p>第一步：在channel上开启确认模式：channel.confirmSelect（）</p>
<p>第二步：在channel上添加监听：addConfirmListenter，监听成功和失败的返回结果，根据具体的结果对消息进行重新发送，或记录日志等后续处理！</p>
<p>handleNack(long deliveryTag, boolean multiple)；</p>
<p>handleAck(long deliveryTag, boolean multiple)；</p>
<h3 id="return-消息机制"><a href="#return-消息机制" class="headerlink" title="return 消息机制"></a>return 消息机制</h3><p>return Listener 用于处理一些不可路由的消息</p>
<p>我们的消息生产者，通过指定一个Exchange 和 routingKey，把消息送达到某一个队列中去，然后我们的消息者监听队列，进行消费处理操作！</p>
<p>但是在某些情况下，如果我们在发送消息的时候，当前的Exchange不存在或者指定的路由Key路由不到。这个时候如果我们需要监听这种不可达的消息。就要使用ReturnListener！</p>
<p>基础API中有一个关键的配置项</p>
<p>Mandatory：如果为true，则监听器会接收到路由不可达的消息，然后进行后续处理，如果为false,那么broker端自动删除该消息！（默认为false）</p>
<p><img src="images%5CRabbitMQ%5C5.png" alt="5"></p>
<p>发送消息channel.basicPublish(exchagename(如果为“”则表示默认路由:direct),routekey,Mandatory(是否监听路由不可达消息),props,body);</p>
<p>监听channel.addReturnListener</p>
<p>实现public void HandleReturn(int replayCode,String replayText,String exchange,String routingKey,AMQP.BasicProperties,byte[] Body)</p>
<h3 id="消费端自定义监听"><a href="#消费端自定义监听" class="headerlink" title="消费端自定义监听"></a>消费端自定义监听</h3><p>我们一般就是在代码中编写while循环，进行consumer.nextDelivery方法进行获取吓一条消息，然后进行消费处理。</p>
<p>但是我们使用自定义的consumer更加的方便，解耦性更加的强，也在实际工作中最常用的使用方法！</p>
<p>1、实现Consumer(方法太多)  2、 继承DefaultConsumer</p>
<p><img src="images%5CRabbitMQ%5C6.jpg" alt="6"></p>
<h3 id="消费端限流"><a href="#消费端限流" class="headerlink" title="消费端限流"></a>消费端限流</h3><p>什么是消费端的限流？</p>
<p>​    假设一个场景，首先，我们rabbitMq服务器上有上万条未处理的消息，我们随便打开一个消费者客户端，会出现下面情况：</p>
<p>​    巨量的消息瞬间全部推送过来，但是我们单个客户端无法同时处理这么多数据！</p>
<p>Rabbitmq 提供了一种QOS（服务质量保证）功能，即在非自动确认消息的前提下，如果一定数目的消息（通过基于consumer 或者channel设置QoS的值）未被确认前，不进行消费新的消息。</p>
<p>Void BasiQos(unit prefetchSize ,ushort prefetchCount,bool Global)</p>
<p>prefetchSize:0(不限制大小)</p>
<p>prefetchCount:会告诉RabbitMq不要同时给一个消费者推送多于N个消息，即一旦有N个消息还没有Ack，则该Consumer将block掉，知道有消息ack。</p>
<p>global：       true、false是否将上面设置应用于channel</p>
<p>​            简单点说，就是上面限制是channel级别的还是consumer级别</p>
<p>prefetchSize 和 global这两项，rabbitmq没有实现，暂且不研究prefetch_count在no_ack-false的情况下生效，即在自动应答的情况下这两个值是不生效的。</p>
<h3 id="消息端ACK与重回队列"><a href="#消息端ACK与重回队列" class="headerlink" title="消息端ACK与重回队列"></a>消息端ACK与重回队列</h3><p>消费端的手工Ack 和Nack</p>
<p>消息端进行消费的时候，如果由于业务异常我们可以进行日志的记录，然后进行补偿。</p>
<p>如果由于服务器宕机等严重问题，那我们就需要手工ACK保障消费端消费成功。</p>
<p>消费端的重回队列</p>
<p>消费端重回队列是为了对没有处理成功的消息，把消息重新回递给broker！</p>
<p>一般我们在实际应用中，都会关闭重回队列，也就是设置为false！</p>
<h3 id="TTL队列-消息"><a href="#TTL队列-消息" class="headerlink" title="TTL队列/消息"></a>TTL队列/消息</h3><p>TTL</p>
<p>​    TTL是Time To Live 的缩写，也就是生存时间</p>
<p>​    RabbitMQ支持消息的过期时间，在消息发送时可以进行指定</p>
<p>​    rabbitMq支持队列的过期时间，从消息开始计算，只要超过了队列的超时时间配置，那么消息会自动的清除</p>
<h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><p>DLX ，Dead-Letter-Exchane</p>
<p>利用DLX，当消息在一个队列变成死信（dead message）之后，他能被重新publish到另一个Exchange这个Exchange就是DLX</p>
<p>消息变成死信有以下几种情况</p>
<p>​    消息被拒绝（basic.reject/basic.nack）并且requeue = false</p>
<p>​    消息TTL过期</p>
<p>​    队列达到最大长度</p>
<p>DLX也是一个正常的Exchange，和一般的Exchange没有区别，他能在任何的队列上被指定，实际上就是设置某一个队列的属性。</p>
<p>当这个队列中有死信时，Rabbitmq 就是自动的将这个消息重新发布到设置的Exchange上去，进而被路由到另一个队列。</p>
<p>可以监听这个队列中消息做相应的处理，这个特性可以弥补RabbitMq3.0以前支持的immediate参数的功能。</p>
<p>死信队列设置：</p>
<p>​    首先需要设置死信队列的Exchange和queue，然后进行绑定：</p>
<p>​        Exchange：dlx.exhange</p>
<p>​        QUeue:dlx.quere</p>
<p>​        Routingkey：#</p>
<p>然后我们进行正常声明交换机、队列、绑定，只不过我们需要在对列加上一个参数即可：arguments.put(“x-dead-letter-exchange”,”dlx.exchange”);</p>
<p>这样消息在过期、requeue、队列在达到最大长度时，消息就可以直接路由到死信对列</p>
<h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><h4 id="本章导航-1"><a href="#本章导航-1" class="headerlink" title="本章导航"></a>本章导航</h4><p>RabbitMQ整合Spring AMQP 实战</p>
<p>RabbitMQ整合Spring Boot 实战</p>
<p>RabbitMQ整合Spring Cloud 实战</p>
<h4 id="RabbitMQ整合Spring-AMQP-实战"><a href="#RabbitMQ整合Spring-AMQP-实战" class="headerlink" title="RabbitMQ整合Spring AMQP 实战"></a>RabbitMQ整合Spring AMQP 实战</h4><p>RabbitAdmin</p>
<p>​    RabbitAdmin类可以很好的操作RabbitMQ,在Spring中直接进行注入即可</p>
<p>​    注意：autoStartup必须要设置为true，否则Spring容器不会加载RabbitAdMin类</p>
<p>​    rabbitAdmin底层实现就是从Spring容器中获取Exchange、Binding、RoutingKey以及Queue的@Bean声明</p>
<p>​    然后使用RabbitTemplate的execute方法执行对应的声明、修改、删除等一系列rabbitMq基础功能操作</p>
<p>​    例如一个交换机、删除一个绑定、清空一个队列里的消息等等</p>
<p>SpringAMQP声明</p>
<p>RabbitTemplate</p>
<p>SimpleMessageListenerContainer</p>
<p>messageListenerAdapter</p>
<p>MessageConverter</p>
<p>在Rabbit基础api里面声明一个Exchange、声明一个绑定、一个对列 。</p>
<p>使用SpringAMQP去声明，就需要使用SpringdeAMQP的如下模式，即声明@Bean方式</p>
<h5 id="消息模板-rabbitTemplate"><a href="#消息模板-rabbitTemplate" class="headerlink" title="消息模板-rabbitTemplate"></a>消息模板-rabbitTemplate</h5><p>我们在与SpringAMQP整合的时候进行发送消息的关键类</p>
<p>该类提供了丰富的发送消息的方法，包括可靠性投递消息方法，回调监听消息接口confirmcallback、返回值确认接口returncallback等等。同样我们需要进行注入到Spring容器中，然后直接使用</p>
<p>在与spring整合时需要实例化，但是在与springboot整合时，在配置文件里添加配置即可</p>
<h3 id="SimpleMessageListenerContainer"><a href="#SimpleMessageListenerContainer" class="headerlink" title="SimpleMessageListenerContainer"></a>SimpleMessageListenerContainer</h3><p>简单消息监听器</p>
<p>这个类非常的强大，我们可以对他进行很多设置，对于消费者的配置项，这个类都可以满足</p>
<p>监听队列（多个队列）、自动启动、自动声明功能</p>
<p>设置事务特性、事务管理器、事务属性、事务容量（并发）、是否开启事务、回滚消息等</p>
<p>设置消费者数量、最小最大数量、批量消费</p>
<p>设置消息确认和自动确认模式、是否重回队列、异常捕获handler函数</p>
<p>设置消费者标签生成策略、是否独占模式、消费者属性等</p>
<p>设置具体的监听器、消息转换器等等</p>
<p>注意：SimpleMessageListenerContainer 可以进行动态设置，比如在运行中的应用可以动态的修改其消费者数量的大小、接收消息的模式等</p>
<p>很多基于Rabbitmq的自制定化后端管控台在进行动态设置的时候，也是根据这一特性去实现的，所以可以看出springamqp非常的强大。</p>
<p>SimpleMessageListenerContainer 为什么可以进行动态设置?</p>
<h3 id="MessageListenerdapter-消息监听适配器"><a href="#MessageListenerdapter-消息监听适配器" class="headerlink" title="MessageListenerdapter 消息监听适配器"></a>MessageListenerdapter 消息监听适配器</h3><p>通过messagelisteneradpter的代码我们可以看出如下核心属性</p>
<p>defaultListenerMethod 默认监听方法名称，用于设置监听方法名称</p>
<p>Delegate：委派对象 实际真实的委派对象，用于处理消息</p>
<p>queueOrTagTOMethodName队列标识与方法名称组合的集合</p>
<p>可以—进行队列与方法名称的匹配</p>
<p>队列和方法名称绑定，级置顶队列里的消息会被绑定的方法接收处理</p>
<h4 id="MessageConverter-消息转化器"><a href="#MessageConverter-消息转化器" class="headerlink" title="MessageConverter 消息转化器"></a>MessageConverter 消息转化器</h4><p>我们在进行发送消息的时候，正常情况下消息体为二进制的数据方式进行传输，如果希望内部帮我们进行转换，或者指定自定义的转换器，就需要用到MessageConvert</p>
<p>自定义常用转换器：MessageConverter，一般来讲都需要实现这个接口</p>
<p>重写下面俩个方法：</p>
<p>​    toMessage：Java对象转换为Message</p>
<p>​    fromMessage:message对象转化为Java对象</p>
<p>json转换器：Jackson2jsonMessageConverter：可以进行Java对象的转换功能</p>
<p>DefaultJackson2JavaTypeMapper映射器：可以进行Java对象的映射关系</p>
<p>自定义二进制转换器：比如图片类型、PDF、PPT、流媒体</p>
<h3 id="SpringBoot整合配置详解"><a href="#SpringBoot整合配置详解" class="headerlink" title="SpringBoot整合配置详解"></a>SpringBoot整合配置详解</h3><p>publish-confirms，实现一个监听器用于监听broker端给我们返回的确认请求：Rabbittemplate.ConfitmCallback</p>
<p>publisher-returns，保证消息对broker端是可达的，如果出现路由键不可达的情况下，则使用监听器对不可达的消息进行后续的处理，保证消息的路由成功：RabbitTenplate.returnCallback</p>
<p>注意一点，在发送消息的时候对template进行配置mandatory=true保证监听有效</p>
<p>生产端还可以配置其他属性，比如发送重试，超时时间、次数、间隔等</p>
<p>消费端核心配置</p>
<p><img src="images%5CRabbitMQ%5C7.jpg" alt="7"></p>
<p>首先配置手工确认模式，用于ack的手工处理，这样我们可以保证消息的可靠性送达，或者在消费端消失失败的时候可以做到重回队列、根据业务记录日志等处理</p>
<p>可以设置消费端的监听个数和最大个数，用于控制消费端的并发情况</p>
<p>@RabbitListener注解使用</p>
<p>消费端监听@RabbitMQListener注解，这个对于在实际工作中非常的好用</p>
<p>@RabbitListener是一个组合注解，里面可以注解配置</p>
<p>@QueueBinding、@Queue、@Exchange直接通过这个组合注解一次性搞定消费端交换机、队列、绑定、路由、并且配置监听功能等</p>
<h2 id="Spring-Cloud-Stream-整合"><a href="#Spring-Cloud-Stream-整合" class="headerlink" title="Spring Cloud Stream 整合"></a>Spring Cloud Stream 整合</h2><p>Spring Cloud,这个全家桶框架在整个中小型互联网公司异常的火爆，那么相对应着，Spring Cloud Stream就渐渐的被大家所重视起来，</p>
<p>这一节课主要来介绍Spring CloudStream如何与RabbitMq进行集成</p>
<p><img src="images%5CRabbitMQ%5C8.jpg" alt="8"></p>
<p><img src="images%5CRabbitMQ%5C9.jpg" alt="9"></p>
<p><img src="images%5CRabbitMQ%5C10.jpg" alt="10"></p>
<p>Barista接口：Barista接口是定义来作为后面类的参数，这一接口定义来通道类型和通道名称，通道名称是作为配置用，通道类型则决定了APP会使用这一通道进行发送消息还是从中接收消息</p>
<p>@Output：输出注解，用于定义发送消息接口</p>
<p>@Input：输入注解，用于定义消息的消费者接口</p>
<p>@StreamListener：用于定义监听方法的注解</p>
<p>使用SpringCloudStream非常简单，只需要使用好这三个注解即可，可实现高性能消息的生产和消费的场景非常适合，但是使用SpringCloudStream 框架有一个非常大的问题就是不能实现可靠性的投递，也就是没法保证消息的100%可靠性，会存在少量消息丢失的问题</p>
<p>这个原因是因为SpringCloudStream框架为了和kafka兼顾所以在实际工作中使用他的目的就是针对高性能的消息通信的！这点就是在当前版本Spring Cloud Stream 的定位</p>
<h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h3 id="本章导航-2"><a href="#本章导航-2" class="headerlink" title="本章导航"></a>本章导航</h3><p>首先是了解RabbitMq集群架构模式</p>
<p>接下来从零开始构建一个高可靠的RabbitMq集群</p>
<p>集群的配置文件与集群运维故障、失败转移讲解</p>
<p>高级插件的使用</p>
<p>主备模式：实现RabbitMq的高可用集群，一般在并发和数据量不高的情况下，这种模式非常的好用且简单。主备模式也称为Warren模式</p>
<h3 id="主备模式（一）"><a href="#主备模式（一）" class="headerlink" title="主备模式（一）"></a>主备模式（一）</h3><p>主备模式：所谓的rabbitMq另外一种模式就是Warren（兔子窝），就是一个主、备方案（主节点如果挂了，从节点提供服务而已，和activemq利用zookeeper做主/备一样）</p>
<p><img src="images%5CRabbitMQ%5C11.jpg" alt="11"></p>
<h3 id="主备模式（三）"><a href="#主备模式（三）" class="headerlink" title="主备模式（三）"></a>主备模式（三）</h3><p>Haproxy配置：</p>
<p>listen rabbitmq_cluster</p>
<p>bind 0.0.0.0:5672 #配置TCP模式</p>
<p>mode tcp #简单的轮询</p>
<p>balance roundrobin #主节点</p>
<p>server bhz76 192.168.11.76:5672 check inter 5000 rise 2 fail 2</p>
<p>server bhz77 192.168.11.77:5672 backup check inter 5000 rise 2 fail 2 #备用节点</p>
<p>备注：rabbitmq集群节点配置#inter每隔五秒对mq集群做健康检查，2次正确证明服务器可用，2次失败证明服务器不可用，并且配置主备机制</p>
<h3 id="RabbitMq集群架构模式"><a href="#RabbitMq集群架构模式" class="headerlink" title="RabbitMq集群架构模式"></a>RabbitMq集群架构模式</h3><p>远程模式：远程模式可以实现双活的一种模式，简称shovel模式，所谓shovel就是我们可以吧消息进行不同数据中心的复制工作，我们可以跨地域的让俩个mq集群互联</p>
<h4 id="远程模式（一）"><a href="#远程模式（一）" class="headerlink" title="远程模式（一）"></a>远程模式（一）</h4><p>远程模式：远距离通信和复制，所谓shovel就是我们可以把消息进行不同数据中心的复制工作，我们可以跨地域的让俩个目前集群互联。我们下面看一下shovel架构模型：</p>
<p><img src="images%5CRabbitMQ%5C12.jpg" alt="12"></p>
<p>远程模式：shovel集群的拓扑图如下所示</p>
<p><img src="images%5CRabbitMQ%5C13.jpg" alt="13"></p>
<h4 id="远程模式（四）"><a href="#远程模式（四）" class="headerlink" title="远程模式（四）"></a>远程模式（四）</h4><p>shovel集群的配置，首先启动RabbitMq插件，命令如下：</p>
<p>rabbitmq-plugins enable amqp_client</p>
<p>rabbitmq-plugins enable rabbitmq-shovel</p>
<h4 id="远程模式（五）"><a href="#远程模式（五）" class="headerlink" title="远程模式（五）"></a>远程模式（五）</h4><p>创建rabbitmq.config文件：touch/etc/rabbitmq/rabbitmq.config</p>
<p>添加配置见rabbitmq.config</p>
<p>最后我们需要资源服务器和目的地服务器都使用相同的配置文件（rabbitmq.config）</p>
<p><img src="images%5CRabbitMQ%5C14.jpg" alt="14"></p>
<h3 id="镜像模式"><a href="#镜像模式" class="headerlink" title="镜像模式"></a>镜像模式</h3><p>镜像模式：集群模式非常经典的就是Mirror镜像模式，保证100%数据不丢失，在实际工作中也是用的最多的。并且实现集群非常的简单，一般互联网大厂都会构建这种镜像集群模式</p>
<h4 id="镜像模式（一）"><a href="#镜像模式（一）" class="headerlink" title="镜像模式（一）"></a>镜像模式（一）</h4><p>Mirror镜像队列，目的地为了保证rabbitmq数据的高可靠性解决方案，主要就是实现数据的同步，一般来讲2-3个节点实现数据同步（对于100%数据可靠性解决方案一般3节点）几圈架构如下：</p>
<p><img src="images%5CRabbitMQ%5C15.jpg" alt="15"></p>
<h3 id="多活模式"><a href="#多活模式" class="headerlink" title="多活模式"></a>多活模式</h3><p>多活模式：这种模式也是实现异地数据复制的主流模式，因为Shovel模式比较复杂，所以一般来说实现异地集群都是使用这种双活或者多活模型来去实现的，这种模型需要依赖rabbitmq的federation插件，可以实现持续的可靠的amqp数据通信看，多活模式在实际配置与应用非常的简单</p>
<h5 id="多活模式（一）"><a href="#多活模式（一）" class="headerlink" title="多活模式（一）"></a>多活模式（一）</h5><p>rabbitmq部署架构采用双中心模式（多中心），那么在俩套（或多套）数据中心中各部署一套rabbitmq集群，各中心的rabbitmq服务除了需要为业务提供正常的消息服务外，中心之间还需要实现部分队列消息共享，多活集群架构如下：</p>
<p><img src="images%5CRabbitMQ%5C16.jpg" alt="16"></p>
<h4 id="多活模式（三）"><a href="#多活模式（三）" class="headerlink" title="多活模式（三）"></a>多活模式（三）</h4><p>Federation插件是一个不需要构建Cluster，而在broker是之间传输消息的高性能插件，Federation插件可以在Brokers或者Cluster之间传输消息，链接的双方可以使用不同的users和virtual hosts，双方也可以使用版本不同的rabbitmq和erlang。federation插件使用amqp协议通讯，可以接受不连续的传输</p>
<h4 id="多活模式（四）"><a href="#多活模式（四）" class="headerlink" title="多活模式（四）"></a>多活模式（四）</h4><p>Federation Exchanges，可以看成Downstream从Upstream主动拉取消息，但并不是拉取所有消息，必须是在downstream上已经明确定义Bindings关系的Exchange，也就是有实际的物理Queue来接收消息，才会从Upstream会将绑定关系组合在一起，绑定/解除绑定命令将发送到Upstream交换机。因此，Federation Exchange只接收具有订阅的消息，本处贴出官方图来说明；</p>
<p><img src="images%5CRabbitMQ%5C17.jpg" alt="17"></p>
<p>RabbitMq 集群镜像模式构建</p>
<p><img src="images%5CRabbitMQ%5C18.jpg" alt="18"></p>
<h3 id="Haproxy"><a href="#Haproxy" class="headerlink" title="Haproxy"></a>Haproxy</h3><p>Haproxy是一款提供高可用性、负载均衡以及基于TCP（第四层）和HTTP（第七层）应用的代理软件，支持虚拟主机，他是免费、快速并且可靠的一种解决方案。Haproxy特别适用于哪些负载特大的web站点，这些站点通常又需要会话保持或七层处理。haproxy运行在时下的硬件下，完全可以支持数以万计的并发连接。并且他的运行模式使得他可以很简单安全的整合进您当前的架构中，同时可以保护你的Web服务器不被暴露到网络上</p>
<p>Haproxy性能最大化（一）</p>
<p>haproxy借助于os上几种常见的技术来实现性能的最大化：</p>
<p>1、单进程、事件驱动模型显著降低了上下文切换的开销及内存占用</p>
<p>2、在任何可用的情况下，单缓冲（single buffering）机制能以不复制任何数据的方式完成读写操作，这会节约大量的cpu时钟周期及内存带宽</p>
<p>3、借助于Linux 2.6（&gt;=2.627.19）上的splice（）系统调用，haproxy可以实现零复制转发（zero-copy forwarding），在Linux 3.5及以上的OS中还可以实现零复制启动（zero-starting）</p>
<p>4、内存分配器在固定大小的内存池中可实现即时内存分配，这能够显著减少创建一个会话的时长</p>
<p>5、树形存储：侧重于使用作者多年前开发的弹性二叉树，实现了以O(log(N))的低开销来保持计时器命令、保持运行队列命令一管理轮询及最少连接队列</p>
<h3 id="KeepAlived"><a href="#KeepAlived" class="headerlink" title="KeepAlived"></a>KeepAlived</h3><p>KeepAlived软件主要是通过VRRP协议实现高可用功能的。VRRP是Virtual Router Redundancyprotocol(虚拟路由器冗余协议)的缩写，VRRP出现的目的就是为了解决静态路由单点故障问题的，他能够保证当个别节点宕机时，整个网络可以不间断地运行 所以，Keepalived 一方面具有配置管理LVS的功能，同时还具有对LVS下面节点进行健康检查的功能，另一方面也实现系统网络服务的高可用功能</p>
<h4 id="keepAlived重要特性（一）"><a href="#keepAlived重要特性（一）" class="headerlink" title="keepAlived重要特性（一）"></a>keepAlived重要特性（一）</h4><p>KeepAlived服务的三个重要功能：</p>
<p>管理LVS负载均衡软件</p>
<p>实现LVS集群点的健康检查中</p>
<p>作为系统网络服务的高可用性（failover）</p>
<h4 id="KeepAlived高可用原理"><a href="#KeepAlived高可用原理" class="headerlink" title="KeepAlived高可用原理"></a>KeepAlived高可用原理</h4><p>KeepAlived高可服务对之间的故障切换转移，是通过VRRP（Virtual router redundancy protocol,虚拟路由器冗余协议）来实现的。在Keepalive服务正常工作时，主Master节点会会不断地向备节点发送（多播的方式）心跳消息，用以告诉设备Backup节点自己还会看，当主Master节点发送故障时，就无法发送心跳消息，备节点也就因此无法继续检测到来自Master节点的心跳了，于是调用自身的接管程序，接管主Master节点的IP资源及服务。而当主Master节点恢复时，备Backup节点又会释放主节点故障时自身接管的IP资源及服务，恢复到原来的备用角色</p>
<p>那么什么是VRRP呢？VRRP,全称Virtual Router Redundancy Protocol，中文名为虚拟路由冗余协议，VRRP的出现就是为了解决静态路由的单点故障问题，VRRP是通过一种竞选机制来将路由的任务交给某台VRRP路由器的</p>
<h3 id="集群恢复与故障转移"><a href="#集群恢复与故障转移" class="headerlink" title="集群恢复与故障转移"></a>集群恢复与故障转移</h3><p>RabbitMO镜像队列集群的恢复的解决方案和应用场景<br>√前提:比如两个节点A和B组成一个镜像队列<br>√场景1:A先停,B后停<br>√方案1:该场景下B是 Master,只要先启动B,再启动A即可。或者<br>先启动A,再30秒之内启动B即可恢复镜像队列</p>
<p>√场景2:A、B同时停机<br>√方案2:该场景可能是由于机房掉电等原因造成的,只需在30秒之<br>内连续启动A和B即可恢复镜像</p>
<p>√场景3:A先停,B后停,且A无法恢复<br>√方案3:改场景是1场景的加强版,因为B是 Master,所以等B起来以<br>后,在B节点上调用控制台命令: rabbitmgct<br>forget cluster node A解除与A的 uster关系,再将新的 Slave<br>节点加入B即可重新恢复镜像队列</p>
<p>场景4:A先停,B后停,且B无法恢复<br>ˇ方案4:该场景是场景3的加强版,比较难处理,原因是因为 Master节<br>点无法恢复,早在3.1.x时代之前没有什么好的解决方案,但是现在已经<br>有解决方案了,在3.4.2以后的版本。因为B是主节点,所以直接启动A<br>是不行的,当A无法启动的时候,也就没办法在A节点上调用之前的<br>rabbitmqctl forget cluster node B命令了。新版本中,<br>forget cluster node支持- offline参数（支持线下操作）</p>
<p>√这就意味着允许 rabbitmgctl在理想节点上执行该命令,追使<br>Rabbitmo在未启动Save节点中选择一个节点作为 Master。当在<br>A节点执行 rabbitmqctl forget cluster node- offline B时,<br>RabbitMO会mock一个节点代表A,执行 forget cluster node<br>命令将B剔除 cluster,然后A就可以正常启动了,最后将新的save<br>节点加入A即可重新恢复镜像队列</p>
<p>ˇ场景5:A先停、B后停,且A、B均无法恢复,但是能得到A或B的磁盘文件<br>√方案5:这种场景更加难处理,只能通过恢复数据的方式去尝试恢复,将A或B<br>的数据库文件默认在$ RABBIT HOME/ar/ib/目录中,把它拷贝到新节点的<br>对应 mulia,再将新节点的 hostname改成A或B的 hostname,如果是A节点<br>( Slave)的磁盘文件,则按照场景4处理即可,如果是B节点( Master)的磁<br>盘文件,则按照场景3处理,最后将新的 Slave加入到新节点后完成恢复</p>
<p>√场景6:A先停、B后停,且A、B均无法恢复,且得不到A或B<br>的磁盘文件<br>√嗯,大家可以洗洗睡啦~</p>
<h3 id="延迟插件的作用"><a href="#延迟插件的作用" class="headerlink" title="延迟插件的作用"></a>延迟插件的作用</h3><p>延迟插件作用<br>√延迟队列可以做什么事情?<br>√比如消息的延迟推送、定时任务(消息)的执行。包括一些消息重试策<br>略的配合使用,以及用于业务削峰限流、降级的异步延迟消息机制,都<br>是延迟队列的实际应用场景</p>
<h3 id="互联网Set化架构"><a href="#互联网Set化架构" class="headerlink" title="互联网Set化架构"></a>互联网Set化架构</h3><h4 id="BAT-TMD大厂单元化架构设计衍变之路-一"><a href="#BAT-TMD大厂单元化架构设计衍变之路-一" class="headerlink" title="BAT/TMD大厂单元化架构设计衍变之路(一)"></a>BAT/TMD大厂单元化架构设计衍变之路(一)</h4><p>√随着大型互联网公司业务的多元化发展,就拿滴滴、美团等大厂来讲,如滴<br>滴打车、单车、外卖、酒店、旅行、金融等业务持续高速增长,单个大型分<br>布式体系的集群,通过加机器+集群内部拆分(kv、mq、 MySQL等),虽然<br>具备了一定的可扩展性。但是,随着业务量的进一步增长,整个集群规模逐<br>渐变得巨大,从而一定会在某个点上达到瓶颈,无法满足扩展性需要,并且<br>大集群内核心服务出现问题,会影响全网所有用户。</p>
<h4 id="BAT-TMD大厂单元化架构设计衍变之路-二"><a href="#BAT-TMD大厂单元化架构设计衍变之路-二" class="headerlink" title="BAT/TMD大厂单元化架构设计衍变之路(二)"></a>BAT/TMD大厂单元化架构设计衍变之路(二)</h4><p>以滴滴打车、美团外卖举例来说:<br>打车业务体量巨大,尤其是在早晚高峰期。全年订单量已越10亿。<br>外卖业务体量庞大,目前单量已突破1700W/天,对于如此庞大的单<br>个大型分布式集群,会面临以下问题<br>1、容灾问题<br>2、资源扩展问题<br>3、大集群拆分问题</p>
<h4 id="BAT-TMD大厂单元化架构设计衍变之路-三"><a href="#BAT-TMD大厂单元化架构设计衍变之路-三" class="headerlink" title="BAT/TMD大厂单元化架构设计衍变之路(三)"></a>BAT/TMD大厂单元化架构设计衍变之路(三)</h4><p>√1、容灾问题<br>√核心服务(比如订单服务)挂掉,会影响全网所有用户<br>导致整个业务不可用;<br>数据库主库集中在一个DC,主机房挂掉,会影响全网<br>所有用户,整个业务无法快速切换和恢复;</p>
<h4 id="BAT-TMD大厂单元化架构设计衍变之路-四"><a href="#BAT-TMD大厂单元化架构设计衍变之路-四" class="headerlink" title="BAT/TMD大厂单元化架构设计衍变之路(四)"></a>BAT/TMD大厂单元化架构设计衍变之路(四)</h4><p>ˇ2、资源扩展问题<br>ˇ单DC的资源(机器、网络带宽等)已经没法满足,扩展|DC时,存<br>在跨机房访问时延问题(增加异地机房时,时延问题更加严重)<br>√数据库主库单点,连接数有限,不能支持应用程序的持续扩展;</p>
<h4 id="BAT-TMD大厂单元化架构设计衍变之路-五"><a href="#BAT-TMD大厂单元化架构设计衍变之路-五" class="headerlink" title="BAT/TMD大厂单元化架构设计衍变之路(五)"></a>BAT/TMD大厂单元化架构设计衍变之路(五)</h4><p>√3、大集群拆分问题<br>√核心问题:分布式集群规模扩大后,会相应的带来资源扩展、<br>大集群拆分以及容灾问题。<br>所以出于对业务扩展性以及容灾需求的考虑,我们需要一套从<br>底层架构彻底解决问题的方案,业界主流解决方案<br>√单元化架构方案(阿里、支付宝、饿了么、微信等)</p>
<h4 id="BAT-TMD大厂单元化架构设计衍变之路"><a href="#BAT-TMD大厂单元化架构设计衍变之路" class="headerlink" title="BAT/TMD大厂单元化架构设计衍变之路"></a>BAT/TMD大厂单元化架构设计衍变之路</h4><p>√同城“双活”架构介绍<br>√目前很多大型互联网公司的业务架构可以理解为同城“双活”架构,<br>注意这里的“双活”是加引号的,具体可以这样理解</p>
<h4 id="BAT-TMD大厂单元化架构设计衍变之路-1"><a href="#BAT-TMD大厂单元化架构设计衍变之路-1" class="headerlink" title="BAT/TMD大厂单元化架构设计衍变之路"></a>BAT/TMD大厂单元化架构设计衍变之路</h4><p>√业务层面上已经做到真正的双活(或者多活),分别承担部分流量;<br>√存储层面比如定时任务、缓存、持久层、数据分析等都是主从架构,<br>会有跨机房写;<br>个数据中心故障,可以手动切换流量,部分组件可以自动切换;</p>
<h4 id="BAT-TMD大厂单元化架构设计衍变之路-2"><a href="#BAT-TMD大厂单元化架构设计衍变之路-2" class="headerlink" title="BAT/TMD大厂单元化架构设计衍变之路"></a>BAT/TMD大厂单元化架构设计衍变之路</h4><p>√两地三中心架构介绍<br>√使用灾备的思想,在同城“双活”的基础上,在异地部署一套<br>灾备数据中心,每个中心都具有完备的数据处理能力,只有当<br>主节点故障需要容灾的时候才会紧急启动备用数据中心;</p>
<p><img src="images%5CRabbitMQ%5C19.jpg" alt="19"></p>
<h4 id="BAT-TMD大厂单元化架构设计衍变之路-3"><a href="#BAT-TMD大厂单元化架构设计衍变之路-3" class="headerlink" title="BAT/TMD大厂单元化架构设计衍变之路"></a>BAT/TMD大厂单元化架构设计衍变之路</h4><p>√SET化方案目标<br>√业务:解决业务遇到的扩展性和容灾等需求,支撑业务的高速发展<br>ˇ通用性:架构侧形成统一通用的解决方案,方便各业务线接入使用</p>
<p><img src="images%5CRabbitMQ%5C20.jpg" alt="20"></p>
<h4 id="SET化架构策略"><a href="#SET化架构策略" class="headerlink" title="SET化架构策略"></a>SET化架构策略</h4><p>√流量路由:<br>按照特殊的key(通常为 userid)进行路由,判断某次<br>请求该路由到中心集群还是单元化集群;</p>
<p>√中心集群<br>√未进行单元化改造的服务(通常不在核心交易链路,比如<br>供应链系统)称为中心集群,跟当前架构保持一致。</p>
<p>√单元化集群<br>√每个单元化集群只负责本单元内的流量处理,以实现流量<br>拆分以及故障隔离;<br>√每个单元化集群前期只存储本单元产生的交易数据,后续<br>会做双向数据同步,实现容灾切换需求</p>
<p>√中间件(RPC、KV、MQ等):<br>√RPC:对于SET服务,调用封闭在SET内;对于非SET服务,沿<br>用现有路由逻辑;<br>√KV:支持分SET的数据生产和查询;</p>
<p>√数据同步<br>√全局数据(数据量小且变化不大,比如商家的菜品数据)部署<br>在中心集群,其他单元化集群同步全局数据到本单元化内;<br>未来演变为异地多活架构时,各单元化集群数据需要进行双向<br>同步来实现容灾需要</p>
<p>ˇSE化路由策略及其能力<br>√异地容灾<br>√通过SET化架构的流量调度能力,将SET分别部署在不同<br>地区的数据中心,实现跨地区容灾支持</p>
<p>√高效本地化服务<br>ˇ利用前端位置信息采集和域名解析策略,将流量路由到最近的<br>SET,提供最高效的本地化服务;<br>√比如2O场景天然具有本地生产,本地消费的特点,更加需<br>要SET化支持</p>
<p>√集装箱式扩展<br>√SET的封装性支持更灵活的部署扩展性,比如SET一键创<br>建/下线,SET一键发布等</p>
<p><img src="images%5CRabbitMQ%5C21.jpg" alt="21"></p>
<p><img src="images%5CRabbitMQ%5C22.jpg" alt="22"></p>
<h3 id="SET化重要的原则"><a href="#SET化重要的原则" class="headerlink" title="SET化重要的原则"></a>SET化重要的原则</h3><p>√对业务透明原则:<br>√SET化架构的实现对业务代码透明,业务代码层面不需<br>要关心SET化规则,SET的部署等问题。</p>
<p>√SET化重要的原则<br>√SET切分规则:<br>√理论上,切分规则由业务层面按需定制;<br>√实现上,建议优先选最大的业务维度进行切分;<br>√比如海量用户的O2O业务,按用户位置信息进行切分。此外,<br>接入层、逻辑层和数据层可以有独立的SET切分规则,有利于<br>实现部署和运维成本的最优化。</p>
<p>√SET化重要的原则<br>√部署规范原则<br>√一个SET并不一定只限制在一个机房,也可以跨机房或者<br>跨地区部署;为保证灵活性,单个SET内机器数不宜过多(<br>如不超过1000台物理机)</p>
<p><img src="images%5CRabbitMQ%5C23.jpg" alt="23"></p>
<h4 id="RabbitMO-SET化架构实现"><a href="#RabbitMO-SET化架构实现" class="headerlink" title="RabbitMO-SET化架构实现"></a>RabbitMO-SET化架构实现</h4><p>√使用 RabbitMQ异步消息通信插件 Federation安装与配置<br>v rabbitmq-plugins enable rabbitmq federation<br>v rabbitmq-plugins enable rabbitmq_federation management<br>√备注:当你在一个 cluste中使用 federation插件,所有在集群中的<br>nodes都需要安装 federation插件</p>
<p>使用 RabbitS通信插件 Federation:<br>v Federation插件是一个在不需要 cluster,而 brokers之间传输消<br>息的高性能插件。<br>Federation插件可以在 brokers或者 cluster之间传输消息,链接<br>的双方可以使用不同的 users和 virtual hosts、或者双方的<br>rabbitry和 erlang版本不一致, federation插件使用AMQP协议<br>通信,可以接受不连续的传输。<br>SET化配置规则:<br>第一, Federation Exchanges,可以看成 Downstream(82节点)从 Upstream<br>81节点)主动拉取消息,但并不是拉取所有消息,必须是在 Downstream上已<br>经明确定义 Bindings关系的 Exchange,也就是有实际的物理 Queue来接收消息<br>,才会从 Upstream拉取消息到 Downstream。使用AMQP协议实施代理间通信<br>Downstream会将绑定关系组合在一起,绑定/解除绑定命令将发送到 Upstream<br>交换机</p>
<p>√第二,经过配置后, Upstream节点已经可以把消息直接通过 Federation<br>Exchanges路由给我们的 Downstream节点,然后进行消费<br>也就是说可以实现消息的转发,接下来也可以在 Upstream添加具体的队列去<br>进行消费 Federation Exchanges里的消息,我们一条消息分别发到了2个<br>Rabbits集群并且消费,这样我们可以实现SET化的关键要素,就是集群间<br>的消息同步了</p>
<p>√第三,可以根据自己的业务规则去规划不同的集群去监听不同的消息<br>队列,从而达到SET化的手段,保障了性能、可靠性、数据一致性。</p>
<h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><p>基础组件封装设计-延迟消息发送<br>基础组件封装设计-顺序消息发送<br>基础组件封装设计-事务消息发送<br>消息幂等性保障-消息路由规则架构设计</p>
<img src="images\RabbitMQ\24.jpg" alt="24">



<h4 id="MQ组件实现功能点"><a href="#MQ组件实现功能点" class="headerlink" title="MQ组件实现功能点(-)"></a>MQ组件实现功能点(-)</h4><p>√支持消息高性能的序列化转换、异步化发送消息<br>√支持消息生产实例与消费实例的链接池化缓存化提升性能<br>√支持可靠性投递消息,保障消息的100%不丢失<br>√支持消费端的幂等操作,避免消费端重复消费的问题</p>
<h4 id="MQ组件实现功能点-二"><a href="#MQ组件实现功能点-二" class="headerlink" title="MQ组件实现功能点(二)"></a>MQ组件实现功能点(二)</h4><p>支持迅速消息发送模式,在一些日志收集/统计分析等需求下可以保证<br>高性能,超高吞吐量。<br>支持延迟消息模式,消息可以延迟发送,指定延迟时间,用于某些延<br>迟检查、服务限流场景<br>支持事务消息,且100%保障可靠性投递,在金融行业单笔大金额操作<br>时会有此类需求</p>
<h4 id="MQ组件实现功能点-三"><a href="#MQ组件实现功能点-三" class="headerlink" title="MQ组件实现功能点(三)"></a>MQ组件实现功能点(三)</h4><p>√支持顺序消息,保证消息送达消费端的前后顺序,例如下订单等复合性操作<br>√支持消息补偿,重试,以及快速定位异常/失败消息<br>√支持集群消息负载均衡,保障消息落到具体SE「集群的负载均衡<br>√支持消息路由策略,指定某些消息路由到指定的SET集群</p>
<img src="images\RabbitMQ\25.png" alt="25">

<p><img src="images%5CRabbitMQ%5C26.png" alt="26"></p>
<h4 id="消息发送模式-批量消息发送-一"><a href="#消息发送模式-批量消息发送-一" class="headerlink" title="消息发送模式-批量消息发送(一)"></a>消息发送模式-批量消息发送(一)</h4><p>√批量消息是指我们把消息放到一个集合里统一进行提交,这种方案设计思路<br>是期望消息在一个会话里,比如投掷到 Ithreadlocal里的集合,然后拥有相同<br>会话D,并且带有这次提交消息的SzE等相关属性,最重要的一点是要把这<br>批消息进行合并。对于 Channe而言,就是发送一次消息。这种方式也是<br>希望消费端在消费的时候,可以进行批量化的消费,针对于某一个原子业务<br>的操作去处理,但是不保障可靠性,需要进行补偿机制。</p>
<p><img src="images%5CRabbitMQ%5C27.png" alt="27"></p>
<h4 id="消息发送模式-延迟消息发送"><a href="#消息发送模式-延迟消息发送" class="headerlink" title="消息发送模式-延迟消息发送"></a>消息发送模式-延迟消息发送</h4><p>ˇ延迟消息相对简单,就是我们在 Message封装的时候添加 delay Time属<br>性即可,使得我们的消息可以进行延迟发送,根据具体的业务场景也可<br>以很好的使用得到!</p>
<p>√场景举例:<br>√比如你在电商平台买到的商品签收后,不点击确认支付,那么系统自动<br>会在7天(一定时间)去进行支付操作<br>√还有一些自动超时作废的场景,你的优惠券有使用时间限制,也可<br>以用延迟消息机制</p>
<h4 id="消息发送模式-顺序消息-一"><a href="#消息发送模式-顺序消息-一" class="headerlink" title="消息发送模式-顺序消息(一)"></a>消息发送模式-顺序消息(一)</h4><p>√顺序消息,比较类似于批量消息的实现机制,但是也有些不同。<br>√我们要保障以下几点<br>√1发送的顺序消息,必须保障消息投递到同一个队列,且这个消费者只能有一个<br>(独占模式)<br>√2然后需要统一提交(可能是合并成一个大消息也可能是拆分为多个消息),并且<br>所有消息的会话|D一致<br>√3添加消息属性:顺序标记的序号、和本次顺序消息的SzE属性,进行落库操作</p>
<h4 id="消息发送模式-顺序消息-二"><a href="#消息发送模式-顺序消息-二" class="headerlink" title="消息发送模式-顺序消息(二)"></a>消息发送模式-顺序消息(二)</h4><p>√4并行进行发送给自身的延迟消息(注意带上关键属性:会话|D、SZE)进<br>行后续处理消费<br>√5当收到延迟消息后,根据会话D、SZE抽取数据库数据进行处理即可<br>√6定时轮训补偿机制,对于异常情况<br>备注:比如生产端消息没有完全投递成功、或者消費端落库异常<br>导致消费端落库后缺少消息条目的情况)</p>
<p><img src="images%5CRabbitMQ%5C28.png" alt="28"></p>
<h4 id="消息发送模式-事务消息发送-一"><a href="#消息发送模式-事务消息发送-一" class="headerlink" title="消息发送模式-事务消息发送(一)"></a>消息发送模式-事务消息发送(一)</h4><p>√事务消息,相对使用比较少见,但是本神在早期做互联网金融行业<br>中,面对单笔大额的现金流交易时遇到过:比如单笔转账超过一个<br>上限的时候,我们就希望这个消息优先级最高,并且可靠性要求达<br>到100%,当然我们的系统和银行端系统都要兼顾才行,所以也会有<br>些补偿机制,主动发起银行端查询指令机制等。</p>
<h4 id="消息发送模式-事务消息发送-二"><a href="#消息发送模式-事务消息发送-二" class="headerlink" title="消息发送模式-事务消息发送(二)"></a>消息发送模式-事务消息发送(二)</h4><p>为了保障性能的同时,也支持事务。我们井没有选择传统的 RabbitS<br>事务和 Spring集成的机制,因为在性能测试的过程中,效果并不理想<br>非常消耗系统资源目会出现阻塞等情况,在高峰期也是一定程度上影<br>响MQ集群的性能</p>
<h4 id="消息发送模式-事务消息发送-三"><a href="#消息发送模式-事务消息发送-三" class="headerlink" title="消息发送模式-事务消息发送(三)"></a>消息发送模式-事务消息发送(三)</h4><p>√解决方案<br>√我们采用类似可靠性投递的机制,也就是补偿机制<br>√但是我们的数据源必须是同一个,也就是业务操作DB1数据库和消息记录DB2<br>数据库使用同一个数据源<br>√然后利用重写 Spring Data Source TransactionManager,在本地事务提交的<br>时候进行发送消息,但是也有可能事务提交成功但是消息发送失败,这个时候<br>就需要进行补偿了。</p>
<p><img src="images%5CRabbitMQ%5C29.png" alt="29"></p>
<p><img src="images%5CRabbitMQ%5C30.png" alt="30"></p>
<h4 id="消息的幂等性的必要性"><a href="#消息的幂等性的必要性" class="headerlink" title="消息的幂等性的必要性"></a>消息的幂等性的必要性</h4><p>√保障消息的幂等性,这也是我们在使用MQ中至关重要的环节<br>√可能导致消息出现非幂等的原因<br>√1可靠性消息投递机制<br>ˇ2 MQ Broker服务与消费端传输消息的过程中的网络抖动<br>√3消费端故障或异常</p>
<p><img src="images%5CRabbitMQ%5C31.png" alt="31"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/" data-id="ck46kswf1000764sso7cay5v1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/12/15/学习文档/MQ/RocketMQ/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2019/12/15/学习文档/MQ/KAFKA/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/12/15/raids/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/12/15/学习文档/项目管理/github/github学习/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/12/15/学习文档/项目管理/git/idea-git配置/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/12/15/学习文档/项目管理/git/git学习文档/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/12/15/学习文档/框架/SOA架构和微服务架构的区别/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>