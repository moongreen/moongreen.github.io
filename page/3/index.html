<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-学习文档/spring/SpringBoot/springBoot学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/15/学习文档/spring/SpringBoot/springBoot学习/" class="article-date">
  <time datetime="2019-12-15T05:32:18.588Z" itemprop="datePublished">2019-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、异常处理与单元测试"><a href="#一、异常处理与单元测试" class="headerlink" title="一、异常处理与单元测试"></a>一、异常处理与单元测试</h3><h4 id="1、异常处理"><a href="#1、异常处理" class="headerlink" title="1、异常处理"></a>1、异常处理</h4><p>​            1.1springboot对于异常处理提供的5种方式</p>
<p>​                1.1.1自定义错误页面</p>
<p>​                    springboot默认的处理异常的机制：异常时向/error发送请求。（BasicErrorController处理/error）</p>
<p>​                    自定义：1、创建一个名为error.html（必须叫error）页面  2、timestamp、status、error、message、path可以直接获取异常信息 3、所有异常将调到该页面</p>
<p>​                1.1.2@ExceptionHandle注解处理异常</p>
<p>​                    @ExceptionHandle(value={处理异常的类.class})</p>
<p>​                    ModelAndView method(Exception e){};</p>
<p>​                    不具备跨controller的能力</p>
<p>​                                1.1.3@ControllerAdvice+@ExceptionHandler注解处理异常</p>
<p>​                    全局处理异常</p>
<p>​                    </p>
<p>​                                1.1.4配置SimpleMappingExceptionResolver处理异常</p>
<p>​                    简化@ExceptionHandler（多个简化为一个方法）</p>
<p>​                    配置类@Configuration</p>
<p>​                    添加method 返回值必须是 SimpleMappingExceptionResolver</p>
<p>​                    只能创建映射但是不能传递异常信息</p>
<p>​                    /**</p>
<p>​                    * 通过 SimpleMappingExceptionResolver 做全局异常处理 </p>
<p>​                    *</p>
<p>​                    *</p>
<p>​                    */ </p>
<p>​                    @Configuration </p>
<p>​                    public class** GlobalException { </p>
<p>​                    /**</p>
<p>​                    * 该方法必须要有返回值。返回值类型必须是： </p>
<p>​                        SimpleMappingExceptionResolver </p>
<p>​                    */ </p>
<p>​                    @Bean </p>
<p>​                    public SimpleMappingExceptionResolver getSimpleMappingExceptionResolver(){ </p>
<p>​                        SimpleMappingExceptionResolver resolver = <strong>new</strong> </p>
<p>​                        SimpleMappingExceptionResolver(); </p>
<p>​                        Properties mappings = <strong>new</strong> Properties(); </p>
<p>​                        /**</p>
<p>​                            * 参数一：异常的类型，注意必须是异常类型的全名 </p>
<p>​                            * 参数二：视图名称 </p>
<p>​                        */ </p>
<p>​                        mappings.put(“java.lang.ArithmeticException”, “error1”); </p>
<p>​                        mappings.put(“java.lang.NullPointerException”,”error2”); </p>
<p>​                        //设置异常与视图映射信息的 </p>
<p>​                        resolver.setExceptionMappings(mappings); </p>
<p>​                        <strong>return</strong> resolver; </p>
<p>​                         } </p>
<p>​                }</p>
<p>​                1.1.5自定义HandleExceptionResolver类处理异常</p>
<p>​                    实现HandleExceptionResolver接口 </p>
<p>​                    resolveException(request,response,e)</p>
<h3 id="2、单元测试"><a href="#2、单元测试" class="headerlink" title="2、单元测试"></a>2、单元测试</h3><p>​    2.1测试启动类 </p>
<p>​        2.1.1@RunWith(SpringJUnit4ClassRunner.class) 启动器 （juint与spring环境进行整合） 或者子类 SpringRunner.class</p>
<p>​        2.1.2@SpringBootTest(classes={App.class}) 1、当前类为springboot的测试类 2、加载SpringBoot启动类，启动springboot</p>
<p>​        2.1.3 等价于2.1.2   junit与spring整合@Contextconfiguartion（classpath:application.yml）</p>
<h3 id="二、Springboot热部署"><a href="#二、Springboot热部署" class="headerlink" title="二、Springboot热部署"></a>二、Springboot热部署</h3><p>两种方式：</p>
<h4 id="1、springLoader"><a href="#1、springLoader" class="headerlink" title="1、springLoader"></a>1、springLoader</h4><!-- springloader 插件 --> 

<build> 

<p><plugins><plugin> </plugin></plugins></p>
<p><groupid>org.springframework.boot</groupid> </p>
<p><artifactid>spring-boot-maven-plugin</artifactid> </p>
<dependencies> 

<dependency> 

<p><groupid>org.springframework</groupid> </p>
<p><artifactid>springloaded</artifactid> </p>
<p><version>1.2.5.RELEASE</version> </p>
</dependency> 

</dependencies> 

 

 

</build>



<p>需要使用spring-boot：run启动项目</p>
<p>SpringLoader 缺陷：就是 Java 代码做部署处理。但是对页面无能为力。</p>
<p><strong>注意：这种方式的缺点是</strong> <strong>Springloader</strong> 热部署程序是在系统后台以进程的形式来运行。*需要手动关闭该进程</p>
<p>直接使用springLoader架包</p>
<h4 id="2、DevTools工具"><a href="#2、DevTools工具" class="headerlink" title="2、DevTools工具"></a>2、DevTools工具</h4><p>与springLoader的区别</p>
<p>springLoader：在部署时使用的是<strong>热部署</strong>的方式</p>
<p>DevTools：在部署时使用<strong>重新部署</strong>的放肆</p>
<h3 id="三、整合缓冲技术"><a href="#三、整合缓冲技术" class="headerlink" title="三、整合缓冲技术"></a>三、整合缓冲技术</h3><h4 id="1、Ehcache"><a href="#1、Ehcache" class="headerlink" title="1、Ehcache"></a>1、Ehcache</h4><h5 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h5><p>开启支持缓冲的启动器spring-boot-stater-cache</p>
<p>Ehcache坐标</p>
<p>在ehcahe架包内 ehcahe-failsafe.xml 内的xml内容移植到自己创建的ehcache.xml文件内</p>
<p>&lt;defaultCache   //默认缓冲策略</p>
<p>​    maxElementInMemory=”10000” // </p>
<p>​    eternal=”false”</p>
<p>​    timeToIdleSeconds=”120”</p>
<p>​    timeToLiveSeconds=”120”</p>
<p>​    maxElementsOnDisk=”10000000”</p>
<p>​    diskExpiryThreadIntervalSeconds=”120”</p>
<p>​    memoryStoreEvictionPolicy=”LRU”&gt;</p>
<p><cache></cache> //自定义缓冲策略</p>
<h5 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h5><p>spring.cache.ehcache.cofnig=ehcache.xml</p>
<h5 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h5><p>@EnableCaching</p>
<h5 id="业务层"><a href="#业务层" class="headerlink" title="业务层"></a>业务层</h5><p>@Cacheable(value=”users”) 当前查询的对象开启缓冲</p>
<h5 id="实体类users"><a href="#实体类users" class="headerlink" title="实体类users"></a>实体类users</h5><p>实现serializable可序列化接口</p>
<h4 id="2、-Cacheable"><a href="#2、-Cacheable" class="headerlink" title="2、@Cacheable"></a>2、@Cacheable</h4><p>参数一 value 指定一个 Ehcache 配置文件中的缓存策略，如果么有给定 value，name 则 </p>
<p>表示使用默认的缓存策略。</p>
<p>参数二 key <code>#object</code> 给存储的值起个名称。在查询时如果有名称相同的，那么则知己从缓存中将 </p>
<p>数据返回</p>
<p><strong>未加#时</strong>需要注意的是，@Cacheable注解中的key属性除了需要被英文双引号引用外，还需要加入英文单引号，否则系统在执行缓存操作时将出错。</p>
<h4 id="3、-CacheEvict"><a href="#3、-CacheEvict" class="headerlink" title="3、@CacheEvict"></a>3、@CacheEvict</h4><p>作用：清除缓冲</p>
<p>参数一 value </p>
<p>参数二 allEntrues=true  //@CacheEvict(value=”users”,allEntries=true) 清除缓存中以 users 缓存策略缓存的对象 </p>
<h1 id="三-、缓冲技术–redis"><a href="#三-、缓冲技术–redis" class="headerlink" title="三 、缓冲技术–redis"></a>三 、缓冲技术–redis</h1><p>添加spring data-redis 依赖</p>
<p>完成 对Redis的整合的一些配置</p>
<p>@Configuration//配置类</p>
<p>@Bean JedisPoolConfig对象 连接池</p>
<p>new –》 config.setMaxIdle(20)//最大空闲数   setMinIdle(10) 最小  setMaxTotal(20) 最大连接数</p>
<p>@Bean JedisConnectionFactory 配置redis链接信息  hostname port poolconfig</p>
<p>@Bean RedisTemplate 用于执行Redis操作的方法     connctionFactory    key序列化器 value 序列化器</p>
<h1 id="四、Spring-data-JPA"><a href="#四、Spring-data-JPA" class="headerlink" title="四、Spring-data JPA"></a>四、Spring-data JPA</h1><h4 id="一、spring-Data-JPA介绍"><a href="#一、spring-Data-JPA介绍" class="headerlink" title="一、spring Data JPA介绍"></a>一、spring Data JPA介绍</h4><p>spring data:其实spring data就是spring提供了一个操作数据的框架。而spring data JPA 只是spring data框架下的一个基于JPA的标准操作数据的模块。</p>
<p>spring data jpa:基于jpa的标准对数据进行操作。简化操作持久层的代码。只需要缩写接口就可以</p>
<h4 id="二、spring-boot-整合spring-jpa"><a href="#二、spring-boot-整合spring-jpa" class="headerlink" title="二、spring boot 整合spring jpa"></a>二、spring boot 整合spring jpa</h4><p>1、搭建环境</p>
<p>data-jpa 架包</p>
<p>2、dao层</p>
<p>定义接口 继承JpaRepository&lt;T,T1&gt;</p>
<p>T:当前需要映射的实体</p>
<p>T1:当前映射的实体中的OID的类型</p>
<h4 id="三、spring-data-jpa-提供核心接口"><a href="#三、spring-data-jpa-提供核心接口" class="headerlink" title="三、spring data jpa 提供核心接口"></a>三、spring data jpa 提供核心接口</h4><h5 id="1、repository-lt-T-T1-gt"><a href="#1、repository-lt-T-T1-gt" class="headerlink" title="1、repository&lt;T,T1&gt;"></a>1、repository&lt;T,T1&gt;</h5><h6 id="1-1提供了方法名称命名查询方式"><a href="#1-1提供了方法名称命名查询方式" class="headerlink" title="1.1提供了方法名称命名查询方式"></a>1.1提供了方法名称命名查询方式</h6><p>方法的名称必须遵循驼峰命名规则，findBy（关键字）+属性名称（首字母大写）（查询条件（首字母小写） ）返回List</p>
<p>and  findBy（关键字）+属性名称（首字母大写）+And(关键字)+属性名称（首字母大写）（多个属性名称）</p>
<p>or    同上</p>
<p>like findBy（关键字）+属性名称（首字母大写）+Like(关键字) (属性名称+注意加通配符%)</p>
<h6 id="1-2提供了基于-Query注解查询与更新"><a href="#1-2提供了基于-Query注解查询与更新" class="headerlink" title="1.2提供了基于@Query注解查询与更新"></a>1.2提供了基于@Query注解查询与更新</h6><p>@Query(“from Student where name=?”)// Student  实体名  nativeQuery 默认为false</p>
<p>@Query(value=”select * from student where name=?”,nativeQuery=true) // nativeQuery 是否标准的sql语句</p>
<p>@Query + @Modifying(只执行更新操作)</p>
<p>(@Test +@Transactional 一起使用时事务会自动回滚 必须再加上@Rollback(false) 取消自动回滚)</p>
<p>2、CrudRepository</p>
<p>对数据进行增删改查的操作。注意：该接口继承了Repository接口</p>
<p>3、PagingAndSortingRepository</p>
<p>提供了分页与排序的功能 注意：该接口继承了CrudRepository接口</p>
<p>方法（不能带有条件的查询）</p>
<p>4、JpaRepository</p>
<p>该接口继承了PagingAndSortingRepository接口。对继承的父类接口方法返回值的适配</p>
<p>5、JPASpecificationExecutor</p>
<p>多条件查询的支持（可添加分页与排序）</p>
<p>注意：单独存在（没有继承上几个接口）</p>
<p>Specification<t>(){</t></p>
<p>​    Predicate:封装了单个查询条件</p>
<p>​    Root<t> 查询对象的属性的封装</t></p>
<p>​    CriteriaQuert&lt;?&gt; query：封装了我们要执行的查询各个部分的信息select from order by</p>
<p>​    CriteriaBuilder cb 查询条件的构造器。定义不同的查询条件</p>
<p>​    public  Predicate toPredicate(Root<t> root,CriteriaQuert&lt;?&gt; query,CriteriaBuilder cb){</t></p>
<p>​    }</p>
<p>}</p>
<h4 id="四、关联映射操作"><a href="#四、关联映射操作" class="headerlink" title="四、关联映射操作"></a>四、关联映射操作</h4><p>1、 一对多的关联关系</p>
<p>@ManyToOne 多对一</p>
<p>@JoinColumn（name=“外键ID”）:维护外键</p>
<p>@OneToMany 一对多</p>
<p>2、多对多关联关系</p>
<p>@ManyToMany</p>
<p>@JoinTable（name=“中间表名”，joinColumns=@JoinColumn(name=”当前表中的主键所关联的中间表中的外键字段”)，inverseJoinColums=@JoinColumn(name=”关联表另一张表的外键”)）:映射中间表</p>
<p>@ManyToMany（mappedBy=”关联的另一张表的映射属性”）</p>
<h1 id="五、SpringBoot-定时任务"><a href="#五、SpringBoot-定时任务" class="headerlink" title="五、SpringBoot 定时任务"></a>五、SpringBoot 定时任务</h1><p>一、一、Scheduled定时任务器</p>
<p>​    Scheduled定时任务器：是Spring3.0以后自带的一个定时任务器</p>
<p>添加Scheduled架包 spring-context-support</p>
<p>@Component（类）</p>
<p>@Scheduled （cron=”cron属性：cron表达式。定时任务触发是时间的一个字符串表达形式”）:设置定时任务（方法）</p>
<p>cron表达式：</p>
<p>1、六个域表达式 0/2 * * * * *</p>
<p>启动类开启@EnableScheduling</p>
<p>一、二、整合Quartz定时任务器</p>
<p>java开发的</p>
<p>Quartz 的使用思路</p>
<p>1）job 任务-你要做什么事？</p>
<p>2）Trigger-触发器 你什么时候做？</p>
<p>3）Scheduler-任务调度 你什么时候需要去作什么？参数（job,Trigger）</p>
<p>SoringBoot整合添加</p>
<p>quartz架包</p>
<p>spring-context-support</p>
<p>Spring-tx 事务架包</p>
<p>@configuration 配置类</p>
<p>@Bean</p>
<p>JobDetailFactory</p>
<p>1、关联自己的job类（实现job接口）</p>
<p>@Bean</p>
<p>SimpleTriggerFactoryBean（JobDetailFactory）或者cronTriggerFactoryBean(JobDetailFactory)</p>
<p>1、关联JobDetail对象</p>
<p>2、该参数表示一个执行的毫秒数</p>
<p>3、重复次数</p>
<p>@Bean</p>
<p>SchedulerFactory Bean (SimpleTriggerFactoryBean)</p>
<p>启动类开启@EnableScheduling</p>
<p>注意可以使用：cron表达式</p>
<p>@Component</p>
<p>@autowired</p>
<p>AutowireCapableBeanFactory 可以将一个对象添加到springIoc容器中</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/15/学习文档/spring/SpringBoot/springBoot学习/" data-id="ck46kswfo000h64ssfrx48chq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-学习文档/spring/SpringBoot/idea-springboot学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/15/学习文档/spring/SpringBoot/idea-springboot学习/" class="article-date">
  <time datetime="2019-12-15T05:32:18.545Z" itemprop="datePublished">2019-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、注意架包导入问题（去除冲突架包）"><a href="#一、注意架包导入问题（去除冲突架包）" class="headerlink" title="一、注意架包导入问题（去除冲突架包）"></a>一、注意架包导入问题（去除冲突架包）</h1><p>​    module setting </p>
<h1 id="二、初次使用Thymeleaf引入无效-xmlns-th-”http-www-thymeleaf-org-quot"><a href="#二、初次使用Thymeleaf引入无效-xmlns-th-”http-www-thymeleaf-org-quot" class="headerlink" title="二、初次使用Thymeleaf引入无效   xmlns:th=”http://www.thymeleaf.org&quot;"></a>二、初次使用Thymeleaf引入无效   xmlns:th=”<a href="http://www.thymeleaf.org&quot;" target="_blank" rel="noopener">http://www.thymeleaf.org&quot;</a></h1><p>   查看插件</p>
<h1 id="三、xml-的命名空间"><a href="#三、xml-的命名空间" class="headerlink" title="三、xml 的命名空间"></a>三、xml 的命名空间</h1><p>​    idea，选择Fille|Settings…菜单，再选择Language &amp; Framework | Schemas and DTDs</p>
<h1 id="四-spring-data-redis-2-0-8"><a href="#四-spring-data-redis-2-0-8" class="headerlink" title="四 spring data-redis 2.0.8"></a>四 spring data-redis 2.0.8</h1><p>使用Letture</p>
<p>letture配置文件：</p>
<p>LettuceConnectionFactory  //autowired</p>
<p>@bean KeyGenerator //缓冲key生成器</p>
<p>@Bean CacheManager //缓冲管理器</p>
<p>@Bean RedisTemplate //缓冲系列化策略</p>
<p>使用 RedisTemplate  //autowired</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/15/学习文档/spring/SpringBoot/idea-springboot学习/" data-id="ck46kswfo000i64ssivwgfg30" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-学习文档/spring/SpringBoot/classpath和classpath区别：" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/15/学习文档/spring/SpringBoot/classpath和classpath区别：/" class="article-date">
  <time datetime="2019-12-15T05:32:18.524Z" itemprop="datePublished">2019-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>classpath和classpath*区别： </p>
<p>classpath：只会到你的class路径中查找找文件。</p>
<p>classpath*：不仅包含class路径，还包括jar文件中（class路径）进行查找。</p>
<p>注意： 用classpath<em>:需要遍历所有的classpath，所以加载速度是很慢的；因此，在规划的时候，应该尽可能规划好资源文件所在的路径，尽量避免使用classpath</em>。</p>
<p>classpath*的使用：</p>
<p>当项目中有多个classpath路径，并同时加载多个classpath路径下（此种情况多数不会遇到）的文件，<em>就发挥了作用，如果不加</em>，则表示仅仅加载第一个classpath路径。</p>
<p>一些使用技巧：</p>
<p>1、从上面使用的场景看，可以在路径上使用通配符*进行模糊查找。比如：</p>
<p><param-value>classpath:applicationContext-<em>.xml</em></param-value><br>2、”<em>\</em>\/“表示的是任意目录；”**/applicationContext-*.xml”表示任意目录下的以”applicationContext-“开头的XML文件。  </p>
<p>3、程序部署到tomcat后，src目录下的配置文件会和class文件一样，自动copy到应用的WEB-INF/classes目录下；classpath:与classpath*:的区别在于，前者只会从第一个classpath中加载，而 后者会从所有的classpath中加载。</p>
<p>4、如果要加载的资源，不在当前ClassLoader的路径里，那么用classpath:前缀是找不到的，这种情况下就需要使用classpath*:前缀。</p>
<p>5、在多个classpath中存在同名资源，都需要加载时，那么用classpath:只会加载第一个，这种情况下也需要用classpath*:前缀。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/15/学习文档/spring/SpringBoot/classpath和classpath区别：/" data-id="ck46kswfm000f64ssf47r4a2r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-学习文档/redis/Redis应用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/15/学习文档/redis/Redis应用/" class="article-date">
  <time datetime="2019-12-15T05:32:18.336Z" itemprop="datePublished">2019-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、执行lua脚本"><a href="#一、执行lua脚本" class="headerlink" title="一、执行lua脚本"></a>一、执行lua<strong>脚本</strong></h1><p>使用Lua脚本的好处：</p>
<p>减少网络开销。可以将多个请求通过脚本的形式一次发送，减少网络时延。<br>原子操作。redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。因此在编写脚本的过程中无需担心会出现竞态条件，无需使用事务。<br>复用。客户端发送的脚本会永久存在redis中，这样，其他客户端可以复用这一脚本而不需要使用代码完成相同的逻辑。</p>
<p>基本使用<br>命令格式：<br>EVAL script numkeys key [key …] arg [arg …]<br>说明：</p>
<p>script是第一个参数，为Lua 5.1脚本。该脚本不需要定义Lua函数（也不应该）。<br>第二个参数numkeys指定后续参数有几个key。<br>key [key …]，是要操作的键，可以指定多个，在lua脚本中通过KEYS[1], KEYS[2]获取<br>arg [arg …]，参数，在lua脚本中通过ARGV[1], ARGV[2]获取。<br>简单实例：<br>127.0.0.1:6379&gt; eval “return ARGV[1]” 0 100<br>“100”<br>127.0.0.1:6379&gt; eval “return {ARGV[1],ARGV[2]}” 0 100 101<br>1) “100”<br>2) “101”<br>127.0.0.1:6379&gt; eval “return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}” 2 key1 key2 first second<br>1) “key1”<br>2) “key2”<br>3) “first”<br>4) “second”</p>
<p>127.0.0.1:6379&gt; eval “redis.call(‘SET’, KEYS[1], ARGV[1]);redis.call(‘EXPIRE’, KEYS[1], ARGV[2]); return 1;” 1 test 10 60<br>(integer) 1<br>127.0.0.1:6379&gt; ttl test<br>(integer) 59<br>127.0.0.1:6379&gt; get test<br>“10”<br>注：</p>
<p>{}在lua里是指数据类型table，类似数组。<br>redis.call()可以调用redis命令。<br>命令行里使用<br>如果直接使用redis-cli命令，格式会有点不一样：<br>redis-cli –eval lua_file key1 key2 , arg1 arg2 arg3<br>注意的地方：</p>
<p>eval 后面参数是lua脚本文件,.lua后缀<br>不用写numkeys，而是使用,隔开。注意,前后有空格。<br>示例：</p>
<p>incrbymul.lua<br>local num = redis.call(‘GET’, KEYS[1]);  </p>
<p>if not num then<br>    return 0;<br>else<br>    local res = num * ARGV[1];<br>    redis.call(‘SET’,KEYS[1], res);<br>    return res;<br>end<br>命令行运行：<br>$ redis-cli –eval incrbymul.lua lua:incrbymul , 8<br>(integer) 0<br>$ redis-cli incr lua:incrbymul<br>(integer) 1<br>$ redis-cli –eval incrbymul.lua lua:incrbymul , 8<br>(integer) 8<br>$ redis-cli –eval incrbymul.lua lua:incrbymul , 8<br>(integer) 64<br>$ redis-cli –eval incrbymul.lua lua:incrbymul , 2<br>(integer) 128<br>由于redis没有提供命令可以实现将一个数原子性的乘以N倍，这里我们就用Lua脚本实现了，运行过程中确保不会被其它客户端打断。</p>
<h3 id="整合Springboot"><a href="#整合Springboot" class="headerlink" title="整合Springboot:"></a>整合Springboot:</h3><p>1、选择redisTemplate序列化方式<br>首先，创建一个redisTemplate,具体代码就不说了，这个比较简单。要注意的是，需要设置redisTemplate的序列化方式，springBoot默认是基于java jdk的序列化。通过这种序列化后的参数传到Lua脚本是，是无法正常打印到redis日志的，会出现乱码，而且参数如果传的是一个Map或List的话，不方便解析。并且这种序列化占用的字节比较大。所以改成JSON序列化，用FastJson实现。</p>
<p>2、在springboot中，是用 DefaultRedisScript 类来加载脚本的，并设置相应的数据类型来接收lua脚本返回的数据，这个泛型类在使用时设置泛型是什么类型，脚本返回的结果就是用什么类型接收。注意，该类只接收4种类型的返回类型 Boolean List Long deserialized</p>
<p>3、在lua脚本中，有两个全局的变量，是用来接收redis应用端传递的键值和其它参数的，分别为KEYS、ARGV。</p>
<p>在应用端传递给KEYS时是一个数组列表，在lua脚本中通过索引方式获取数组内的值。</p>
<p>在应用端，传递给ARGV的参数比较灵活，可以是多个独立的参数，但对应到Lua脚本中是，统一用ARGV这个数组接收，获取方式也是通过数组下标获取</p>
<p>4、代码中，redis.log()函数向运日志中输出信息，这里要注意一下，函数里面设置的日志级别要和redis.conf配置文件中设置的日志级别一样才能正常打印到文件，这里我是设置成了deubg级别。这里可设置的级别有4种，分别如下：</p>
<p>redis.LOG_DEBUG<br>redis.LOG_VERBOSE<br>redis.LOG_NOTICE<br>redis.LOG_WARNING<br>在应用端，我们设置接收返回的数据类型是List，所以在Lua脚本中，返回的类型用table与之对应，并且放到table变量中的内容，得是字符串，应用端才能通过反序列化，正常解析。</p>
<h1 id="二、常用场景"><a href="#二、常用场景" class="headerlink" title="二、常用场景"></a>二、常用场景</h1><p>redis应用场景总结redis平时我们用到的地方蛮多的，下面就了解的应用场景做个总结：</p>
<p>1、热点数据的缓存<br>由于redis访问速度块、支持的数据类型比较丰富，所以redis很适合用来存储热点数据，另外结合expire，我们可以设置过期时间然后再进行缓存更新操作，这个功能最为常见，我们几乎所有的项目都有所运用。</p>
<p>2、限时业务的运用<br>redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。</p>
<p>3、计数器相关问题<br>redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。</p>
<p>4、排行榜相关问题<br>关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的SortedSet进行热点数据的排序。</p>
<p>在奶茶活动中，我们需要展示各个部门的点赞排行榜， 所以我针对每个部门做了一个SortedSet,然后以用户的openid作为上面的username,以用户的点赞数作为上面的score, 然后针对每个用户做一个hash,通过zrangebyscore就可以按照点赞数获取排行榜，然后再根据username获取用户的hash信息，这个当时在实际运用中性能体验也蛮不错的。</p>
<p>? 5、分布式锁<br>这个主要利用redis的setnx命令进行，setnx：”set if not exists”就是如果不存在则成功设置缓存同时返回1，否则返回0?，这个特性在俞你奔远方的后台中有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock，如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间 就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。</p>
<p>当然我们可以将这个特性运用于其他需要分布式锁的场景中，结合过期时间主要是防止死锁的出现。</p>
<p>6、延时操作<br>这个目前我做过相关测试，但是还没有运用到我们的实际项目中，下面我举个该特性的应用场景。 比如在订单生产后我们占用了库存，10分钟后去检验用户是够真正购买，如果没有购买将该单据设置无效，同时还原库存。 由于redis自2.8.0之后版本提供Keyspace Notifications功能，允许客户订阅Pub/Sub频道，以便以某种方式接收影响Redis数据集的事件。 所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个key，同时设置10分钟后过期， 我们在后台实现一个监听器，监听key的实效，监听到key失效时将后续逻辑加上。 当然我们也可以利用rabbitmq、activemq等消息中间件的延迟队列服务实现该需求。</p>
<p>7、分页、模糊搜索<br>redis的set集合中提供了一个zrangebylex方法，语法如下：</p>
<p>ZRANGEBYLEX key min max [LIMIT offset count]</p>
<p>通过ZRANGEBYLEX zset - + LIMIT 0?10 可以进行分页数据查询，其中-?+表示获取全部数据</p>
<p>zrangebylex key min max 这个就可以返回字典区间的数据，利用这个特性可以进行模糊查询功能，这个也是目前我在redis中发现的唯一一个支持对存储内容进行模糊查询的特性。</p>
<p>前几天我通过这个特性，对学校数据进行了模拟测试，学校数据60万左右，响应时间在700ms左右，比mysql的like查询稍微快一点，但是由于它可以避免大量的数据库io操作，所以总体还是比直接mysql查询更利于系统的性能保障。</p>
<p>8、点赞、好友等相互关系的存储<br>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。 又或者在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。</p>
<p>这个在奶茶活动中有运用，就是利用set存储用户之间的点赞关联的，另外在点赞前判断是否点赞过就利用了sismember方法，当时这个接口的响应时间控制在10毫秒内，十分高效。</p>
<p>9、队列<br>由于redis有list push和list pop这样的命令，所以能够很方便的执行队列操作。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/15/学习文档/redis/Redis应用/" data-id="ck46kswf7000c64ss4nazd0z8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-学习文档/redis/redis 实现锁机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/15/学习文档/redis/redis 实现锁机制/" class="article-date">
  <time datetime="2019-12-15T05:32:18.323Z" itemprop="datePublished">2019-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/15/学习文档/redis/redis 实现锁机制/" data-id="ck46kswdz000564ssujowld7w" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-学习文档/redis/redis 实现多种语言实现锁机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/15/学习文档/redis/redis 实现多种语言实现锁机制/" class="article-date">
  <time datetime="2019-12-15T05:32:18.310Z" itemprop="datePublished">2019-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、一个可靠的、高可用的分布式锁需要满足以下几点</p>
<p>互斥性：任意时刻只能有一个客户端拥有锁，不能被多个客户端获取</p>
<p>安全性：锁只能被持有该锁的客户端删除，不能被其它客户端删除</p>
<p>死锁：获取锁的客户端因为某些原因而宕机，而未能释放锁，其它客户端也就无法获取该锁，需要有机制来避免该类问题的发生</p>
<p>高可用：当部分节点宕机，客户端仍能获取锁或者释放锁</p>
<p>二、利用单节点Redis实现分布式锁</p>
<p>利用单节点Redis实现分布式锁是最常用的一种方式，虽然没有考虑高可用，但是实现简单、成本低廉而被很多中小型企业所采用。</p>
<p>网上很多文章说采用setnx实现分布式锁，但是setnx命令无法原子性的设置锁的自身过期时间，也就是说执行setnx命令时我们无法同时设置其过期时间，那么就会出现死锁，例如：客户端A刚执行完setnx，这时候客户端A挂掉了，没有完成给锁设置过期时间，此时就产生了死锁，所有的客户端再也无法获得该锁，这种情况一般采用Lua脚本来实现（因为Redis执行Lua脚本是原子性的），其实从 Redis 2.6.12 版本开始set命令完全可以替代setnx命令，我们看官网的set命令参数</p>
<p>SET key value [EX seconds] [PX milliseconds] [NX|XX]</p>
<p>参数说明：</p>
<p>EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。</p>
<p>PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。</p>
<p>NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。</p>
<p>XX ：只在键已经存在时，才对键进行设置操作。</p>
<p>例如：SET key value NX PX 30000 这个命令的作用是在只有这个key不存在的时候才会设置这个key的值（NX选项的作用），超时时间设为30000毫秒（PX选项的作用）</p>
<p>那么我们用set命令带上EX或者PX、以及NX参数就满足了上面提到的互斥性（加锁）、死锁（自动过期）两个要求。</p>
<p>那么如何满足安全性这个要求呢？</p>
<p>比如：客户端A拿到锁并设置了锁的过期时间为10S，但是由于某种原因客户端A执行时间超过了10S，此时锁自动过期，那么客户端B拿到了锁，然后客户端A此时正好执行完毕删除锁，但是此时删除的是客户端B加的锁，如何防止这种不安全的情况发生呢？</p>
<p>方案一：</p>
<p>我们可以让获得锁的线程开启一个守护线程，用来给自己的锁“续期”。</p>
<p>当过去了9S，客户端A还没执行完，这时候守护线程会执行expire指令，把锁再“续期”10S,守护线程从第9S开始执行，每9秒执行一次。</p>
<p>当客户端A执行完任务，会显式关掉守护线程。</p>
<p>如果客户端A忽然宕机，由于A线程和守护线程在同一个进程，守护线程也会停下。这把锁到了超时的时候，没人给它续期，也就自动释放了。</p>
<p>方案二：</p>
<p>我们也可以在加锁的时候把set的value值设置成一个唯一标识，标识这个锁是谁加的锁，在删除锁的时候判断是不是自己加的那把锁，如果不是则不删除。</p>
<p>注意：这里隐含了一个新的问题，判断是不是自己加的锁和释放锁是两个独立操作，不是原子性，所以我们需要使用Lua脚本执行判断和释放锁。</p>
<p>三、提高Redis分布式锁的高可用性</p>
<p>在大型的应用中，一般Redis服务都是集群形式，主从复制、Cluster等，由于Slave同步Master是异步的，所以会出现客户端A在Master上加锁，此时Master宕机，Slave没有完成锁的同步，Slave变为Master，客户端B此时可以完成加锁操作，如何解决该问题呢？</p>
<p>官方给出了Redlock算法，大致意思如下：</p>
<p>在分布式版本的算法里我们假设我们有N个Redis Master节点，这些节点都是完全独立的，我们不用任何复制或者其他隐含的分布式协调算法（如果您采用的是Redis Cluster集群此方案可能不适用，因为Redis Cluster是按哈希槽 (hash slot)的方式来分配到不同节点上的，明显存在分布式协调算法）。</p>
<p>我们把N设成5，因此我们需要在不同的计算机或者虚拟机上运行5个master节点来保证他们大多数情况下都不会同时宕机。一个客户端需要做如下操作来获取锁：</p>
<p>1、获取当前时间（单位是毫秒）。</p>
<p>2、轮流用相同的key和随机值（客户端的唯一标识）在N个节点上请求锁，在这一步里，客户端在每个master上请求锁时，会有一个和总的锁释放时间相比小的多的超时时间。比如如果锁自动释放时间是10秒钟，那每个节点锁请求的超时时间可能是5-50毫秒的范围，这个可以防止一个客户端在某个宕掉的master节点上阻塞过长时间，如果一个master节点不可用了，我们应该尽快尝试下一个master节点。</p>
<p>3、客户端计算第二步中获取锁所花的时间，只有当客户端在大多数master节点上成功获取了锁（在这里是3个），而且总共消耗的时间不超过锁释放时间，这个锁就认为是获取成功了。</p>
<p>4、如果锁获取成功了，那现在锁自动释放时间就是最初的锁释放时间减去之前获取锁所消耗的时间。</p>
<p>5、如果锁获取失败了，不管是因为获取成功的锁不超过一半（N/2+1)还是因为总消耗时间超过了锁释放时间，客户端都会到每个master节点上释放锁，即便是那些他认为没有获取成功的锁。</p>
<p>虽然说RedLock算法可以解决单点Redis分布式锁的高可用问题，但如果集群中有节点发生崩溃重启，还是会出现锁的安全性问题。具体出现问题的场景如下：</p>
<p>假设一共有A, B, C, D, E，5个Redis节点，设想发生了如下的事件序列：</p>
<p>1、客户端1成功锁住了A, B, C，获取锁成功（但D和E没有锁住）</p>
<p>2、节点C崩溃重启了，但客户端1在C上加的锁没有持久化下来，丢失了</p>
<p>3、节点C重启后，客户端2锁住了C, D, E，获取锁成功</p>
<p>这样，客户端1和客户端2同时获得了锁（针对同一资源）。针对这样场景，解决方式也很简单，也就是让Redis崩溃后延迟重启，并且这个延迟时间大于锁的过期时间就好。这样等节点重启后，所有节点上的锁都已经失效了。也不存在以上出现2个客户端获取同一个资源的情况了。</p>
<p>总之用Redis集群实现分布式锁要考虑的特殊情况比较多，尤其是服务器比较多的情况下，需要多测试。</p>
<p>最后给出各种语言实现Redlock算法的代码，感兴趣的朋友可以深入学习下：</p>
<p>Redlock-py (Python 实现)：</p>
<p><a href="https://github.com/SPSCommerce/redlock-py" target="_blank" rel="noopener">https://github.com/SPSCommerce/redlock-py</a></p>
<p>Redlock-php (PHP 实现)：</p>
<p><a href="https://github.com/ronnylt/redlock-php" target="_blank" rel="noopener">https://github.com/ronnylt/redlock-php</a></p>
<p>PHPRedisMutex (PHP 更完整的实现)：</p>
<p><a href="https://github.com/php-lock/lock#phpredismutex" target="_blank" rel="noopener">https://github.com/php-lock/lock#phpredismutex</a></p>
<p>Redsync.go (Go 实现)：</p>
<p><a href="https://github.com/hjr265/redsync.go" target="_blank" rel="noopener">https://github.com/hjr265/redsync.go</a></p>
<p>Redisson (Java 实现)：</p>
<p><a href="https://github.com/redisson/redisson" target="_blank" rel="noopener">https://github.com/redisson/redisson</a></p>
<p>Redis::DistLock (Perl 实现)：</p>
<p><a href="https://github.com/sbertrang/redis-distlock" target="_blank" rel="noopener">https://github.com/sbertrang/redis-distlock</a></p>
<p>Redlock-cpp (C++ 实现)：</p>
<p><a href="https://github.com/jacket-code/redlock-cpp" target="_blank" rel="noopener">https://github.com/jacket-code/redlock-cpp</a></p>
<p>Redlock-cs (C#/.NET 实现)：</p>
<p><a href="https://github.com/kidfashion/redlock-cs" target="_blank" rel="noopener">https://github.com/kidfashion/redlock-cs</a></p>
<p>node-redlock (NodeJS 实现). Includes support for lock extension：</p>
<p><a href="https://github.com/mike-marcacci/node-redlock" target="_blank" rel="noopener">https://github.com/mike-marcacci/node-redlock</a></p>
<p>总结：对于Redis分布式锁需要根据自己的实际情况进行选择是单机还是高可用的集群形式，如果都不满足不妨关注我，下一篇我会讲解用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/15/学习文档/redis/redis 实现多种语言实现锁机制/" data-id="ck46kswf5000b64ssmwpmamwh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-学习文档/MQ/RabbitMQ/AMQP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/15/学习文档/MQ/RabbitMQ/AMQP/" class="article-date">
  <time datetime="2019-12-15T05:32:18.303Z" itemprop="datePublished">2019-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、basic-properties"><a href="#一、basic-properties" class="headerlink" title="一、basic.properties"></a>一、basic.properties</h3><p>1、content-type</p>
<p>2、content-encoding</p>
<p>3、message-id</p>
<p>4、correlation-id</p>
<p>5、app-id</p>
<p>6、user-id</p>
<p>7、timestamp</p>
<p>8、headers</p>
<p>9、expiration</p>
<p>10、delvery-mode</p>
<p>11、type</p>
<p>12、replay-to</p>
<p>13、priority</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/AMQP/" data-id="ck46kswfl000e64ssuz3ah4fb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-学习文档/MQ/RocketMQ" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/15/学习文档/MQ/RocketMQ/" class="article-date">
  <time datetime="2019-12-15T05:32:17.304Z" itemprop="datePublished">2019-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="G:%5C%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3%5CMQ%5Cimages%5CRocketMQ%5C1572074916984.png" alt="1572074916984"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/15/学习文档/MQ/RocketMQ/" data-id="ck46kswf2000864ss1h4z1mxi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-学习文档/MQ/RabbitMQ" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/15/学习文档/MQ/RabbitMQ/" class="article-date">
  <time datetime="2019-12-15T05:32:17.261Z" itemprop="datePublished">2019-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>第一章</p>
<p>主流消息中间件介绍-activeMQ</p>
<p><img src="images%5CRabbitMQ%5C32.png" alt="32"></p>
<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><p>初识 RabbitMO<br>RabbitMQ是一个开源的消息代理和队列服务器,用来通过普通协议<br>在完全不同的应用之间共享数据, RabbitMQ是使用 Erlang语言来编写<br>的,并且 Rabbits是基于AMQP协议的</p>
<p>（跨平台、跨语言）</p>
<h5 id="哪些大厂在用-RabbitMO-为什么"><a href="#哪些大厂在用-RabbitMO-为什么" class="headerlink" title="哪些大厂在用 RabbitMO,为什么?"></a>哪些大厂在用 RabbitMO,为什么?</h5><p>滴滴、美团、头条、去哪儿、艺龙<br>开源、性能优秀,稳定性保障<br>提供可靠性消息投递模式( confirm)、返回模式( return)</p>
<h5 id="哪些大厂在用-RabbitMO-为什么-1"><a href="#哪些大厂在用-RabbitMO-为什么-1" class="headerlink" title="哪些大厂在用 RabbitMO,为什么?"></a>哪些大厂在用 RabbitMO,为什么?</h5><p>与 SpringAMQP完美的整合、AP丰富<br>集群模式丰富,表达式配置,HA模式（实现高可用）,镜像队列模型<br>保证数据不丢失的前提做到高可靠性、可用性</p>
<p>RabbitMO高性能的原因?</p>
<h5 id="√-Erlang语言最初在于交换机领域的架构模式-这样使得"><a href="#√-Erlang语言最初在于交换机领域的架构模式-这样使得" class="headerlink" title="√ Erlang语言最初在于交换机领域的架构模式,这样使得"></a>√ Erlang语言最初在于交换机领域的架构模式,这样使得</h5><p>RabbitMO在 Broker之间进行数据交互的性能是非常优秀的<br>√ Erlang的优点: Erlang有着和原生 Socket一样的延迟</p>
<p>什么是AMQP高级消息队列协议?</p>
<h5 id="√AMQP全称-Advanced-Message-Queuing-Protocol"><a href="#√AMQP全称-Advanced-Message-Queuing-Protocol" class="headerlink" title="√AMQP全称: Advanced Message Queuing Protocol"></a>√AMQP全称: Advanced Message Queuing Protocol</h5><p>√AMQP翻译:高级消息队列协议</p>
<p>什么是AMQP高级消息队列协议?<br>AMQP定义:是具有现代特征的二进制协议。是一个提供统一消息<br>服务的应用层标准高级消息队列协议,是应用层协议的—个开放标<br>准,为面向消息的中间件设计。</p>
<p><img src="images%5CRabbitMQ%5C33.png" alt="33"></p>
<p>导航</p>
<p>1、互联网大厂为什么选择rabbitMq、</p>
<p>2、rabbitMq的高性能之道</p>
<p>3、什么是amqp高级协议</p>
<p>4、amqp核心概念是什么</p>
<p>5、rabbitmq整体架构模型是什么样子的</p>
<p>6、rabbitmq消息是如何流转的</p>
<p>7、rabbitmq安装与使用</p>
<p>8、命令行与管控台</p>
<p>9、rabbitmq消息生成与消费</p>
<p>10、rabbitmq交换机详解</p>
<p>11、rabbitmq队列、绑定、虚拟主机、消息</p>
<p>MQP核心概念<br>Server:又称 Broker,接受客户端的连接,实现AMQP实体服务」<br>Connection:连接,应用程序与 Broker的网络连接</p>
<p>AMQP核心概念<br>Channel:网络信道,几乎所有的操作都在 Channel中进行, Channel<br>是进行消息读写的通道。客户端可建立多个 Channe,每个 Channe代<br>表一个会话任务。</p>
<p>AMQP核心概念<br>Message:消息,服务器和应用程序之间传送的数据,由 Properties<br>和Body组成。 Properties可以对消息进行修饰,比如消息的优先级<br>延迟等高级特性;Body则就是消息体内容。</p>
<p>AMQP核心概念<br>Virtual host:虚拟地址,用于进行逻辑隔离,最上层的消息路由。<br>Virtual Host里面可以有若干个 Exchange和 Queue,同一个 Virtua<br>Host里面不能有相同名称的 Exchange或 Queue</p>
<p>Exchange:交换机,接收消息,根据路由键转发消息到绑定的队列</p>
<p>AMQP核心概念<br>Binding: Exchange和 Queue之间的虚拟连接, binding中可以包含 routing key<br>Routing key:一个路由规则,虛拟机可用它来确定如何路由一个特定消息<br>Queue:也称为 Message Queue,消息队列,保存消息并将它们转发给消费者<img src="images%5CRabbitMQ%5C34.png" alt="34"></p>
<p><img src="images%5CRabbitMQ%5C35.png" alt="35"></p>
<p>安装：</p>
<p>1、rabbitmq与Erlang语言相对应</p>
<p>默认端口号5672</p>
<p>RabbitMO安装与使用<br>服务的启动: rabbitmq- server start&amp;<br>服务的停止: rabbitmgctl stop app<br>管理插件: rabbitmq-plugins enable rabbitmq management<br>访问地址:htp//192168.1176:15672</p>
<p>命令行与管控台-基础操作<br>rabbitmgctl stop app:关闭应用<br>rabbitmgctl start app:启动应用<br>rabbitmgctl status:节点状态</p>
<p>命令行与管控台-基础操作<br>rabbitmgctl add user username password:添加用户<br>rabbitmqctl list users:列出所有用户<br>rabbitmgctl delete user username:删除用户<br>rabbitmgctl clear permissions-p vhostpath username清除用户权限</p>
<p>命令行与管控台-基础操作<br>rabbitmactl list user permissions username:列出用户权限<br>rabbitmgctl change password username newpassword:修改密码<br>rabbitmqctl set permissions-p vhostpath username “*.” “*.” “*.”:设置用户权限</p>
<p>命令行与管控台-基础操作<br>rabbitmqctl add vhost vhostpath:创建虚拟主机<br>rabbitmgctl list vhosts:列出所有虚拟主机<br>rabbitmactl list permissions- p vhostpath:列出虚拟主机上所有权限<br>rabbitmqctl delete vhost vhostpath:删除虚拟主机</p>
<p>命令行与管控台-基础操作<br>V rabbitmqctl list queues:查看所有队列信息<br>v rabbitmgctl- p vhostpath purge queue blue:清除队列里的消息</p>
<p>命令行与管控台高级操作<br>rabbitmgctl reset:移除所有数据,要在 rabbitmgctl stop app之后使用<br>rabbitmqctl join cluster&lt; clusternode&gt;[-ram:组成集群命令<br>rabbitmactl cluster status:查看集群状态</p>
<p>命令行与管控台-高级操作<br>rabbitmgctl change cluster node type disc ram<br>修改集群节点的存储形式<br>rabbitmgctl forget cluster node- offline忘记节点(摘除节点</p>
<p>rabbitmgctl rename cluster node oldnode1 newnode 1 [oldnode2]<br>[newnode2…](修改节点名称)</p>
<p>rabbitmgctl list queues:查看所有队列信息<br>rabbitmgctl- p vhostpath purge queue blue:清除队列里的消息</p>
<p>急速入门-消息生产与消费<br>ConnectionFactory:获取连接工厂(new 同时设置host、port、virtualHost、usename、password)</p>
<p>Connection:一个连接(factory.newConnection())</p>
<p>Channel:数据通信信道,可发送和接收消息（connction.createChannel()）</p>
<p>Queue:具体的消息存储队列</p>
<p>Producer&amp; Consumer生产和消费者</p>
<p>发送消息channel.basicPublish(exchagename(如果为“”则表示默认路由:direct),routekey,props,body);</p>
<h5 id="消费端："><a href="#消费端：" class="headerlink" title="消费端："></a>消费端：</h5><p>1、创建channel</p>
<p>2、声明对列（如果存在则直接返回、否则新建）</p>
<p>channel.queueDeclare(queuename(队列名称),durable（是否持久化）,exlusive（是否排他队列）,autoDelete（自动删除）,arguments（扩展参数Map）);</p>
<p>3、创建消费者</p>
<p>QueueingConsumer quereConsumer = new QueueingConsumer(channel);</p>
<p>4、设置Channel</p>
<p>channel.basicConsume(queuename(队列名称)，autoAck(确认模式：是否自动签收),callback(异步处理消息的方法 quereConsumer )）；</p>
<p><strong>5、获取消息（while）</strong></p>
<p>（一）Delivery delivery = queueConsumer.nextDelivery();//没有消息时会一直阻塞队列   nextDeliveryLong();//阻塞时间</p>
<p>delivery .getBody();//消息体</p>
<p>Envelope envelope = delivery.getEnvelope();//重要的信息</p>
<p>envelope .getDeliveryTag();//</p>
<p>（二）获取消息异步处理 extends DefaultConsumer</p>
<p>实现public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException </p>
<h4 id="Exchange交换机"><a href="#Exchange交换机" class="headerlink" title="Exchange交换机"></a>Exchange交换机</h4><p><img src="images%5CRabbitMQ%5C36.png" alt="36"></p>
<p>交换机属性<br>Name:交换机名称<br>Type:交换机类型 direct（直连型）、 topIc、 fanout、 headers、（system、自定义）</p>
<p>Durability:是否需要持久化,true为持久化</p>
<p>交换机属性<br>Auto delete:当最后一个绑定到 Exchange上的队列删除后,自动删除该 Exchange<br>nternal:当前 Exchange是否用于 RabbitS内部使用,默认为False<br>Arguments:扩展参数,用于扩展AMQP协议自制定化使用</p>
<h5 id="一、Direct-Exchange（直连型路由）"><a href="#一、Direct-Exchange（直连型路由）" class="headerlink" title="一、Direct Exchange（直连型路由）"></a>一、Direct Exchange（直连型路由）</h5><p>所有发送到 Direct Exchange的消息被转发到 RouteKey中指定的 Queue<br>注意: Directi模式可以使用 RabbitMQ自带的 Exchange: default<br>Exchange,所以不需要将 Exchange进行任何绑定( binding)操作,消息传<br>递时, Routekey必须完全匹配才会被队列接收,否则该消息会被抛弃</p>
<h5 id="路由："><a href="#路由：" class="headerlink" title="路由："></a>路由：</h5><p>1、获取channel</p>
<p>2、声明</p>
<p>channel.exchangeDeclare(exchangename(路由器名称),exchangetype（路由器类型）, durable（是否持久化）,autoDelete（是否自动删除）,internal（是否用于 RabbitS内部使用）,artuments（扩展参数）)</p>
<p>3、绑定路由和queue（可以绑多个）</p>
<p>channel.queueBind(queuename,exchangename,routingkey);//持久化路由只能有持久化队列绑定，否则抛出异常</p>
<p><img src="images%5CRabbitMQ%5C37.png" alt="37"></p>
<p>三、Fanout Exchange（广播型）<br>不处理路由键,只需要简单的将队列绑定到交换机上<br>发送到交换机的消息都会被转发到与该交换机绑定的所有队列上<br>Fanout交换机转发消息是最快的</p>
<p><img src="images%5CRabbitMQ%5C39.png" alt="39"></p>
<h5 id="二、Topic-Exchange（主题型路由）"><a href="#二、Topic-Exchange（主题型路由）" class="headerlink" title="二、Topic Exchange（主题型路由）"></a>二、Topic Exchange（主题型路由）</h5><p>所有发送到 Topic Exchange的消息被转发到所有关心 Routekey中指<br>定 Topic的 Queue上<br>Exchange将 RouteKey和某 Topic进行模糊匹配<br>此时队列需要绑定一个 Topic</p>
<p>Topic Exchange</p>
<p>注意:可以使用通配符进行模糊匹配<br>符号“#”匹配一个或多个词<br>符号“*”匹配不多不少一个词<br>例如:“log.#”能够匹配到” log. info.oa”<br>“log.*”只会匹配到” log.erro</p>
<p><img src="images%5CRabbitMQ%5C38.png" alt="38"></p>
<p>Binding-绑定（过个路由也可以绑定：且消息会传递）<br>Exchange和 Exchange、 Queue之间的连接关系<br>Binding中可以包含 RoutingKeyi或者参数</p>
<p>Queue-消息队列<br>消息队列,实际存储消息数据<br>Durability:是否持久化, Durable:是, Transient:否<br>Auto delete:如选yes,代表当最后一个监听被移除之后,<br>该 Queue会自动被删除</p>
<p>Message-消息<br>服务器和应用程序之间传送的数据<br>本质上就是一段数据,由 Properties和 Payload(Body)组成<br>常用属性: delivery_mode(1、非持久化，2、持久化)、 headers(自定义属性Map)</p>
<p>Message-其他属性<br>content-type、 content-encoding、 priority（优先级0-9）<br>correlation_id、 reply _to(返回队列)、 expiration（过期时间）、 message_id<br>timestamp、type、 user_id、 app_id、 cluster_id</p>
<h3 id="获取basic-properties"><a href="#获取basic-properties" class="headerlink" title="获取basic.properties:"></a>获取basic.properties:</h3><p>AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder().deliveryMode(2)…build();</p>
<p>Virtual host虚拟主机<br>虚拟地址,用于进行逻辑隔离,最上层的消息路由<br>一个 Virtual Host里面可以有若干个 Exchange和 Queue<br>同一个 Virtual Host里面不能有相同名称的 Exchange或 Queue</p>
<h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><p>消息如何保障100%的投递成功？</p>
<p>幂等性概念详解？</p>
<p>在海量订单产生的业务高峰期，如何避免消息的重复消费问题？</p>
<p>confirm确认消息、return返回消息？</p>
<h3 id="本章导航"><a href="#本章导航" class="headerlink" title="本章导航"></a>本章导航</h3><p>自定义消费者</p>
<p>消息的ACK与重回队列</p>
<p>消息的限流</p>
<p>TTL消息</p>
<p>死信队列</p>
<h3 id="消息如何保障100-的投递成功？"><a href="#消息如何保障100-的投递成功？" class="headerlink" title="消息如何保障100%的投递成功？"></a>消息如何保障100%的投递成功？</h3><p>一、什么是生产端的可靠性投递</p>
<p>​    1、保障消息的成功发出</p>
<p>​    2、保障MQ节点的成功接收</p>
<p>​    3、发送端收到MQ节点（BROKER）确认应答</p>
<p>​    4、完善的消息进行补偿机制</p>
<p>生产端-可靠性投递（一）</p>
<p>BAT/TMD互联网大厂的解决法案</p>
<p>​    消息落库，对消息状态进行打标。</p>
<p>​    消息的延迟投递、做二次确认，回调检查。</p>
<p>生产端-可靠性投递（二）</p>
<p><img src="images%5CRabbitMQ%5C2.jpg" alt="2"></p>
<p>生产端-可靠性投递（三）</p>
<p>保障MQ我们思考第一种可靠性投递，在高并发的场景下是否合适？</p>
<p>消息的延迟投递，做二次确认，回调检查。</p>
<p>生产端-可靠性投递（四）</p>
<p><img src="images%5CRabbitMQ%5C3.jpg" alt="3"></p>
<h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><p>我们可以借鉴数据库的乐观锁机制</p>
<p>比如我们执行一条更新库存的SQL语句</p>
<p>update table set count = count -1,version = vesion + 1 where version = 1</p>
<p>消费端-幂等性保障</p>
<p>在海量订单产生的业务高峰期，如何避免消息的消费问题？</p>
<p>业界主流的幂等性操作：</p>
<p>​    唯一ID+指纹码机制，利用数据库主键去重</p>
<p>​        唯一ID+指纹码机制，利用数据库主键去重</p>
<p>​        select count(1) from table  where ID = 唯一ID+指纹码</p>
<p>​        好处：实现简单</p>
<p>​        坏处：高并发下有数据写入的性能瓶颈</p>
<p>​        解决方案：跟进ID进行分库分表进行算法路由 </p>
<p>​    利用Redis的原子性去实现</p>
<p>​        使用Redis进行幂等、需要考虑的问题</p>
<p>​        第一：我们是否要进行数据落库，如果落库的话，关键解决的问题是数据库和缓存如何做到原子性</p>
<p>​        第二：如果不行落库，那么都储存到缓存中，如何设置定时同步的策略？</p>
<h3 id="confirm确认消息"><a href="#confirm确认消息" class="headerlink" title="confirm确认消息"></a>confirm确认消息</h3><p>理解confirm消息确认机制：</p>
<p>消息的确认，是指生产者投递消息后，如果Broker收到消息，则会给我们生产者一个应答。</p>
<p>生产者进行接收应答，用来确定这条消息是否正常的发送到Broker，这种方式也是消息的可靠性投递的核心保障！</p>
<p><img src="images%5CRabbitMQ%5C4.jpg" alt="4"></p>
<h3 id="confirm确认消息实现"><a href="#confirm确认消息实现" class="headerlink" title="confirm确认消息实现"></a>confirm确认消息实现</h3><p>如何实现confirm确认消息？</p>
<p>第一步：在channel上开启确认模式：channel.confirmSelect（）</p>
<p>第二步：在channel上添加监听：addConfirmListenter，监听成功和失败的返回结果，根据具体的结果对消息进行重新发送，或记录日志等后续处理！</p>
<p>handleNack(long deliveryTag, boolean multiple)；</p>
<p>handleAck(long deliveryTag, boolean multiple)；</p>
<h3 id="return-消息机制"><a href="#return-消息机制" class="headerlink" title="return 消息机制"></a>return 消息机制</h3><p>return Listener 用于处理一些不可路由的消息</p>
<p>我们的消息生产者，通过指定一个Exchange 和 routingKey，把消息送达到某一个队列中去，然后我们的消息者监听队列，进行消费处理操作！</p>
<p>但是在某些情况下，如果我们在发送消息的时候，当前的Exchange不存在或者指定的路由Key路由不到。这个时候如果我们需要监听这种不可达的消息。就要使用ReturnListener！</p>
<p>基础API中有一个关键的配置项</p>
<p>Mandatory：如果为true，则监听器会接收到路由不可达的消息，然后进行后续处理，如果为false,那么broker端自动删除该消息！（默认为false）</p>
<p><img src="images%5CRabbitMQ%5C5.png" alt="5"></p>
<p>发送消息channel.basicPublish(exchagename(如果为“”则表示默认路由:direct),routekey,Mandatory(是否监听路由不可达消息),props,body);</p>
<p>监听channel.addReturnListener</p>
<p>实现public void HandleReturn(int replayCode,String replayText,String exchange,String routingKey,AMQP.BasicProperties,byte[] Body)</p>
<h3 id="消费端自定义监听"><a href="#消费端自定义监听" class="headerlink" title="消费端自定义监听"></a>消费端自定义监听</h3><p>我们一般就是在代码中编写while循环，进行consumer.nextDelivery方法进行获取吓一条消息，然后进行消费处理。</p>
<p>但是我们使用自定义的consumer更加的方便，解耦性更加的强，也在实际工作中最常用的使用方法！</p>
<p>1、实现Consumer(方法太多)  2、 继承DefaultConsumer</p>
<p><img src="images%5CRabbitMQ%5C6.jpg" alt="6"></p>
<h3 id="消费端限流"><a href="#消费端限流" class="headerlink" title="消费端限流"></a>消费端限流</h3><p>什么是消费端的限流？</p>
<p>​    假设一个场景，首先，我们rabbitMq服务器上有上万条未处理的消息，我们随便打开一个消费者客户端，会出现下面情况：</p>
<p>​    巨量的消息瞬间全部推送过来，但是我们单个客户端无法同时处理这么多数据！</p>
<p>Rabbitmq 提供了一种QOS（服务质量保证）功能，即在非自动确认消息的前提下，如果一定数目的消息（通过基于consumer 或者channel设置QoS的值）未被确认前，不进行消费新的消息。</p>
<p>Void BasiQos(unit prefetchSize ,ushort prefetchCount,bool Global)</p>
<p>prefetchSize:0(不限制大小)</p>
<p>prefetchCount:会告诉RabbitMq不要同时给一个消费者推送多于N个消息，即一旦有N个消息还没有Ack，则该Consumer将block掉，知道有消息ack。</p>
<p>global：       true、false是否将上面设置应用于channel</p>
<p>​            简单点说，就是上面限制是channel级别的还是consumer级别</p>
<p>prefetchSize 和 global这两项，rabbitmq没有实现，暂且不研究prefetch_count在no_ack-false的情况下生效，即在自动应答的情况下这两个值是不生效的。</p>
<h3 id="消息端ACK与重回队列"><a href="#消息端ACK与重回队列" class="headerlink" title="消息端ACK与重回队列"></a>消息端ACK与重回队列</h3><p>消费端的手工Ack 和Nack</p>
<p>消息端进行消费的时候，如果由于业务异常我们可以进行日志的记录，然后进行补偿。</p>
<p>如果由于服务器宕机等严重问题，那我们就需要手工ACK保障消费端消费成功。</p>
<p>消费端的重回队列</p>
<p>消费端重回队列是为了对没有处理成功的消息，把消息重新回递给broker！</p>
<p>一般我们在实际应用中，都会关闭重回队列，也就是设置为false！</p>
<h3 id="TTL队列-消息"><a href="#TTL队列-消息" class="headerlink" title="TTL队列/消息"></a>TTL队列/消息</h3><p>TTL</p>
<p>​    TTL是Time To Live 的缩写，也就是生存时间</p>
<p>​    RabbitMQ支持消息的过期时间，在消息发送时可以进行指定</p>
<p>​    rabbitMq支持队列的过期时间，从消息开始计算，只要超过了队列的超时时间配置，那么消息会自动的清除</p>
<h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><p>DLX ，Dead-Letter-Exchane</p>
<p>利用DLX，当消息在一个队列变成死信（dead message）之后，他能被重新publish到另一个Exchange这个Exchange就是DLX</p>
<p>消息变成死信有以下几种情况</p>
<p>​    消息被拒绝（basic.reject/basic.nack）并且requeue = false</p>
<p>​    消息TTL过期</p>
<p>​    队列达到最大长度</p>
<p>DLX也是一个正常的Exchange，和一般的Exchange没有区别，他能在任何的队列上被指定，实际上就是设置某一个队列的属性。</p>
<p>当这个队列中有死信时，Rabbitmq 就是自动的将这个消息重新发布到设置的Exchange上去，进而被路由到另一个队列。</p>
<p>可以监听这个队列中消息做相应的处理，这个特性可以弥补RabbitMq3.0以前支持的immediate参数的功能。</p>
<p>死信队列设置：</p>
<p>​    首先需要设置死信队列的Exchange和queue，然后进行绑定：</p>
<p>​        Exchange：dlx.exhange</p>
<p>​        QUeue:dlx.quere</p>
<p>​        Routingkey：#</p>
<p>然后我们进行正常声明交换机、队列、绑定，只不过我们需要在对列加上一个参数即可：arguments.put(“x-dead-letter-exchange”,”dlx.exchange”);</p>
<p>这样消息在过期、requeue、队列在达到最大长度时，消息就可以直接路由到死信对列</p>
<h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><h4 id="本章导航-1"><a href="#本章导航-1" class="headerlink" title="本章导航"></a>本章导航</h4><p>RabbitMQ整合Spring AMQP 实战</p>
<p>RabbitMQ整合Spring Boot 实战</p>
<p>RabbitMQ整合Spring Cloud 实战</p>
<h4 id="RabbitMQ整合Spring-AMQP-实战"><a href="#RabbitMQ整合Spring-AMQP-实战" class="headerlink" title="RabbitMQ整合Spring AMQP 实战"></a>RabbitMQ整合Spring AMQP 实战</h4><p>RabbitAdmin</p>
<p>​    RabbitAdmin类可以很好的操作RabbitMQ,在Spring中直接进行注入即可</p>
<p>​    注意：autoStartup必须要设置为true，否则Spring容器不会加载RabbitAdMin类</p>
<p>​    rabbitAdmin底层实现就是从Spring容器中获取Exchange、Binding、RoutingKey以及Queue的@Bean声明</p>
<p>​    然后使用RabbitTemplate的execute方法执行对应的声明、修改、删除等一系列rabbitMq基础功能操作</p>
<p>​    例如一个交换机、删除一个绑定、清空一个队列里的消息等等</p>
<p>SpringAMQP声明</p>
<p>RabbitTemplate</p>
<p>SimpleMessageListenerContainer</p>
<p>messageListenerAdapter</p>
<p>MessageConverter</p>
<p>在Rabbit基础api里面声明一个Exchange、声明一个绑定、一个对列 。</p>
<p>使用SpringAMQP去声明，就需要使用SpringdeAMQP的如下模式，即声明@Bean方式</p>
<h5 id="消息模板-rabbitTemplate"><a href="#消息模板-rabbitTemplate" class="headerlink" title="消息模板-rabbitTemplate"></a>消息模板-rabbitTemplate</h5><p>我们在与SpringAMQP整合的时候进行发送消息的关键类</p>
<p>该类提供了丰富的发送消息的方法，包括可靠性投递消息方法，回调监听消息接口confirmcallback、返回值确认接口returncallback等等。同样我们需要进行注入到Spring容器中，然后直接使用</p>
<p>在与spring整合时需要实例化，但是在与springboot整合时，在配置文件里添加配置即可</p>
<h3 id="SimpleMessageListenerContainer"><a href="#SimpleMessageListenerContainer" class="headerlink" title="SimpleMessageListenerContainer"></a>SimpleMessageListenerContainer</h3><p>简单消息监听器</p>
<p>这个类非常的强大，我们可以对他进行很多设置，对于消费者的配置项，这个类都可以满足</p>
<p>监听队列（多个队列）、自动启动、自动声明功能</p>
<p>设置事务特性、事务管理器、事务属性、事务容量（并发）、是否开启事务、回滚消息等</p>
<p>设置消费者数量、最小最大数量、批量消费</p>
<p>设置消息确认和自动确认模式、是否重回队列、异常捕获handler函数</p>
<p>设置消费者标签生成策略、是否独占模式、消费者属性等</p>
<p>设置具体的监听器、消息转换器等等</p>
<p>注意：SimpleMessageListenerContainer 可以进行动态设置，比如在运行中的应用可以动态的修改其消费者数量的大小、接收消息的模式等</p>
<p>很多基于Rabbitmq的自制定化后端管控台在进行动态设置的时候，也是根据这一特性去实现的，所以可以看出springamqp非常的强大。</p>
<p>SimpleMessageListenerContainer 为什么可以进行动态设置?</p>
<h3 id="MessageListenerdapter-消息监听适配器"><a href="#MessageListenerdapter-消息监听适配器" class="headerlink" title="MessageListenerdapter 消息监听适配器"></a>MessageListenerdapter 消息监听适配器</h3><p>通过messagelisteneradpter的代码我们可以看出如下核心属性</p>
<p>defaultListenerMethod 默认监听方法名称，用于设置监听方法名称</p>
<p>Delegate：委派对象 实际真实的委派对象，用于处理消息</p>
<p>queueOrTagTOMethodName队列标识与方法名称组合的集合</p>
<p>可以—进行队列与方法名称的匹配</p>
<p>队列和方法名称绑定，级置顶队列里的消息会被绑定的方法接收处理</p>
<h4 id="MessageConverter-消息转化器"><a href="#MessageConverter-消息转化器" class="headerlink" title="MessageConverter 消息转化器"></a>MessageConverter 消息转化器</h4><p>我们在进行发送消息的时候，正常情况下消息体为二进制的数据方式进行传输，如果希望内部帮我们进行转换，或者指定自定义的转换器，就需要用到MessageConvert</p>
<p>自定义常用转换器：MessageConverter，一般来讲都需要实现这个接口</p>
<p>重写下面俩个方法：</p>
<p>​    toMessage：Java对象转换为Message</p>
<p>​    fromMessage:message对象转化为Java对象</p>
<p>json转换器：Jackson2jsonMessageConverter：可以进行Java对象的转换功能</p>
<p>DefaultJackson2JavaTypeMapper映射器：可以进行Java对象的映射关系</p>
<p>自定义二进制转换器：比如图片类型、PDF、PPT、流媒体</p>
<h3 id="SpringBoot整合配置详解"><a href="#SpringBoot整合配置详解" class="headerlink" title="SpringBoot整合配置详解"></a>SpringBoot整合配置详解</h3><p>publish-confirms，实现一个监听器用于监听broker端给我们返回的确认请求：Rabbittemplate.ConfitmCallback</p>
<p>publisher-returns，保证消息对broker端是可达的，如果出现路由键不可达的情况下，则使用监听器对不可达的消息进行后续的处理，保证消息的路由成功：RabbitTenplate.returnCallback</p>
<p>注意一点，在发送消息的时候对template进行配置mandatory=true保证监听有效</p>
<p>生产端还可以配置其他属性，比如发送重试，超时时间、次数、间隔等</p>
<p>消费端核心配置</p>
<p><img src="images%5CRabbitMQ%5C7.jpg" alt="7"></p>
<p>首先配置手工确认模式，用于ack的手工处理，这样我们可以保证消息的可靠性送达，或者在消费端消失失败的时候可以做到重回队列、根据业务记录日志等处理</p>
<p>可以设置消费端的监听个数和最大个数，用于控制消费端的并发情况</p>
<p>@RabbitListener注解使用</p>
<p>消费端监听@RabbitMQListener注解，这个对于在实际工作中非常的好用</p>
<p>@RabbitListener是一个组合注解，里面可以注解配置</p>
<p>@QueueBinding、@Queue、@Exchange直接通过这个组合注解一次性搞定消费端交换机、队列、绑定、路由、并且配置监听功能等</p>
<h2 id="Spring-Cloud-Stream-整合"><a href="#Spring-Cloud-Stream-整合" class="headerlink" title="Spring Cloud Stream 整合"></a>Spring Cloud Stream 整合</h2><p>Spring Cloud,这个全家桶框架在整个中小型互联网公司异常的火爆，那么相对应着，Spring Cloud Stream就渐渐的被大家所重视起来，</p>
<p>这一节课主要来介绍Spring CloudStream如何与RabbitMq进行集成</p>
<p><img src="images%5CRabbitMQ%5C8.jpg" alt="8"></p>
<p><img src="images%5CRabbitMQ%5C9.jpg" alt="9"></p>
<p><img src="images%5CRabbitMQ%5C10.jpg" alt="10"></p>
<p>Barista接口：Barista接口是定义来作为后面类的参数，这一接口定义来通道类型和通道名称，通道名称是作为配置用，通道类型则决定了APP会使用这一通道进行发送消息还是从中接收消息</p>
<p>@Output：输出注解，用于定义发送消息接口</p>
<p>@Input：输入注解，用于定义消息的消费者接口</p>
<p>@StreamListener：用于定义监听方法的注解</p>
<p>使用SpringCloudStream非常简单，只需要使用好这三个注解即可，可实现高性能消息的生产和消费的场景非常适合，但是使用SpringCloudStream 框架有一个非常大的问题就是不能实现可靠性的投递，也就是没法保证消息的100%可靠性，会存在少量消息丢失的问题</p>
<p>这个原因是因为SpringCloudStream框架为了和kafka兼顾所以在实际工作中使用他的目的就是针对高性能的消息通信的！这点就是在当前版本Spring Cloud Stream 的定位</p>
<h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h3 id="本章导航-2"><a href="#本章导航-2" class="headerlink" title="本章导航"></a>本章导航</h3><p>首先是了解RabbitMq集群架构模式</p>
<p>接下来从零开始构建一个高可靠的RabbitMq集群</p>
<p>集群的配置文件与集群运维故障、失败转移讲解</p>
<p>高级插件的使用</p>
<p>主备模式：实现RabbitMq的高可用集群，一般在并发和数据量不高的情况下，这种模式非常的好用且简单。主备模式也称为Warren模式</p>
<h3 id="主备模式（一）"><a href="#主备模式（一）" class="headerlink" title="主备模式（一）"></a>主备模式（一）</h3><p>主备模式：所谓的rabbitMq另外一种模式就是Warren（兔子窝），就是一个主、备方案（主节点如果挂了，从节点提供服务而已，和activemq利用zookeeper做主/备一样）</p>
<p><img src="images%5CRabbitMQ%5C11.jpg" alt="11"></p>
<h3 id="主备模式（三）"><a href="#主备模式（三）" class="headerlink" title="主备模式（三）"></a>主备模式（三）</h3><p>Haproxy配置：</p>
<p>listen rabbitmq_cluster</p>
<p>bind 0.0.0.0:5672 #配置TCP模式</p>
<p>mode tcp #简单的轮询</p>
<p>balance roundrobin #主节点</p>
<p>server bhz76 192.168.11.76:5672 check inter 5000 rise 2 fail 2</p>
<p>server bhz77 192.168.11.77:5672 backup check inter 5000 rise 2 fail 2 #备用节点</p>
<p>备注：rabbitmq集群节点配置#inter每隔五秒对mq集群做健康检查，2次正确证明服务器可用，2次失败证明服务器不可用，并且配置主备机制</p>
<h3 id="RabbitMq集群架构模式"><a href="#RabbitMq集群架构模式" class="headerlink" title="RabbitMq集群架构模式"></a>RabbitMq集群架构模式</h3><p>远程模式：远程模式可以实现双活的一种模式，简称shovel模式，所谓shovel就是我们可以吧消息进行不同数据中心的复制工作，我们可以跨地域的让俩个mq集群互联</p>
<h4 id="远程模式（一）"><a href="#远程模式（一）" class="headerlink" title="远程模式（一）"></a>远程模式（一）</h4><p>远程模式：远距离通信和复制，所谓shovel就是我们可以把消息进行不同数据中心的复制工作，我们可以跨地域的让俩个目前集群互联。我们下面看一下shovel架构模型：</p>
<p><img src="images%5CRabbitMQ%5C12.jpg" alt="12"></p>
<p>远程模式：shovel集群的拓扑图如下所示</p>
<p><img src="images%5CRabbitMQ%5C13.jpg" alt="13"></p>
<h4 id="远程模式（四）"><a href="#远程模式（四）" class="headerlink" title="远程模式（四）"></a>远程模式（四）</h4><p>shovel集群的配置，首先启动RabbitMq插件，命令如下：</p>
<p>rabbitmq-plugins enable amqp_client</p>
<p>rabbitmq-plugins enable rabbitmq-shovel</p>
<h4 id="远程模式（五）"><a href="#远程模式（五）" class="headerlink" title="远程模式（五）"></a>远程模式（五）</h4><p>创建rabbitmq.config文件：touch/etc/rabbitmq/rabbitmq.config</p>
<p>添加配置见rabbitmq.config</p>
<p>最后我们需要资源服务器和目的地服务器都使用相同的配置文件（rabbitmq.config）</p>
<p><img src="images%5CRabbitMQ%5C14.jpg" alt="14"></p>
<h3 id="镜像模式"><a href="#镜像模式" class="headerlink" title="镜像模式"></a>镜像模式</h3><p>镜像模式：集群模式非常经典的就是Mirror镜像模式，保证100%数据不丢失，在实际工作中也是用的最多的。并且实现集群非常的简单，一般互联网大厂都会构建这种镜像集群模式</p>
<h4 id="镜像模式（一）"><a href="#镜像模式（一）" class="headerlink" title="镜像模式（一）"></a>镜像模式（一）</h4><p>Mirror镜像队列，目的地为了保证rabbitmq数据的高可靠性解决方案，主要就是实现数据的同步，一般来讲2-3个节点实现数据同步（对于100%数据可靠性解决方案一般3节点）几圈架构如下：</p>
<p><img src="images%5CRabbitMQ%5C15.jpg" alt="15"></p>
<h3 id="多活模式"><a href="#多活模式" class="headerlink" title="多活模式"></a>多活模式</h3><p>多活模式：这种模式也是实现异地数据复制的主流模式，因为Shovel模式比较复杂，所以一般来说实现异地集群都是使用这种双活或者多活模型来去实现的，这种模型需要依赖rabbitmq的federation插件，可以实现持续的可靠的amqp数据通信看，多活模式在实际配置与应用非常的简单</p>
<h5 id="多活模式（一）"><a href="#多活模式（一）" class="headerlink" title="多活模式（一）"></a>多活模式（一）</h5><p>rabbitmq部署架构采用双中心模式（多中心），那么在俩套（或多套）数据中心中各部署一套rabbitmq集群，各中心的rabbitmq服务除了需要为业务提供正常的消息服务外，中心之间还需要实现部分队列消息共享，多活集群架构如下：</p>
<p><img src="images%5CRabbitMQ%5C16.jpg" alt="16"></p>
<h4 id="多活模式（三）"><a href="#多活模式（三）" class="headerlink" title="多活模式（三）"></a>多活模式（三）</h4><p>Federation插件是一个不需要构建Cluster，而在broker是之间传输消息的高性能插件，Federation插件可以在Brokers或者Cluster之间传输消息，链接的双方可以使用不同的users和virtual hosts，双方也可以使用版本不同的rabbitmq和erlang。federation插件使用amqp协议通讯，可以接受不连续的传输</p>
<h4 id="多活模式（四）"><a href="#多活模式（四）" class="headerlink" title="多活模式（四）"></a>多活模式（四）</h4><p>Federation Exchanges，可以看成Downstream从Upstream主动拉取消息，但并不是拉取所有消息，必须是在downstream上已经明确定义Bindings关系的Exchange，也就是有实际的物理Queue来接收消息，才会从Upstream会将绑定关系组合在一起，绑定/解除绑定命令将发送到Upstream交换机。因此，Federation Exchange只接收具有订阅的消息，本处贴出官方图来说明；</p>
<p><img src="images%5CRabbitMQ%5C17.jpg" alt="17"></p>
<p>RabbitMq 集群镜像模式构建</p>
<p><img src="images%5CRabbitMQ%5C18.jpg" alt="18"></p>
<h3 id="Haproxy"><a href="#Haproxy" class="headerlink" title="Haproxy"></a>Haproxy</h3><p>Haproxy是一款提供高可用性、负载均衡以及基于TCP（第四层）和HTTP（第七层）应用的代理软件，支持虚拟主机，他是免费、快速并且可靠的一种解决方案。Haproxy特别适用于哪些负载特大的web站点，这些站点通常又需要会话保持或七层处理。haproxy运行在时下的硬件下，完全可以支持数以万计的并发连接。并且他的运行模式使得他可以很简单安全的整合进您当前的架构中，同时可以保护你的Web服务器不被暴露到网络上</p>
<p>Haproxy性能最大化（一）</p>
<p>haproxy借助于os上几种常见的技术来实现性能的最大化：</p>
<p>1、单进程、事件驱动模型显著降低了上下文切换的开销及内存占用</p>
<p>2、在任何可用的情况下，单缓冲（single buffering）机制能以不复制任何数据的方式完成读写操作，这会节约大量的cpu时钟周期及内存带宽</p>
<p>3、借助于Linux 2.6（&gt;=2.627.19）上的splice（）系统调用，haproxy可以实现零复制转发（zero-copy forwarding），在Linux 3.5及以上的OS中还可以实现零复制启动（zero-starting）</p>
<p>4、内存分配器在固定大小的内存池中可实现即时内存分配，这能够显著减少创建一个会话的时长</p>
<p>5、树形存储：侧重于使用作者多年前开发的弹性二叉树，实现了以O(log(N))的低开销来保持计时器命令、保持运行队列命令一管理轮询及最少连接队列</p>
<h3 id="KeepAlived"><a href="#KeepAlived" class="headerlink" title="KeepAlived"></a>KeepAlived</h3><p>KeepAlived软件主要是通过VRRP协议实现高可用功能的。VRRP是Virtual Router Redundancyprotocol(虚拟路由器冗余协议)的缩写，VRRP出现的目的就是为了解决静态路由单点故障问题的，他能够保证当个别节点宕机时，整个网络可以不间断地运行 所以，Keepalived 一方面具有配置管理LVS的功能，同时还具有对LVS下面节点进行健康检查的功能，另一方面也实现系统网络服务的高可用功能</p>
<h4 id="keepAlived重要特性（一）"><a href="#keepAlived重要特性（一）" class="headerlink" title="keepAlived重要特性（一）"></a>keepAlived重要特性（一）</h4><p>KeepAlived服务的三个重要功能：</p>
<p>管理LVS负载均衡软件</p>
<p>实现LVS集群点的健康检查中</p>
<p>作为系统网络服务的高可用性（failover）</p>
<h4 id="KeepAlived高可用原理"><a href="#KeepAlived高可用原理" class="headerlink" title="KeepAlived高可用原理"></a>KeepAlived高可用原理</h4><p>KeepAlived高可服务对之间的故障切换转移，是通过VRRP（Virtual router redundancy protocol,虚拟路由器冗余协议）来实现的。在Keepalive服务正常工作时，主Master节点会会不断地向备节点发送（多播的方式）心跳消息，用以告诉设备Backup节点自己还会看，当主Master节点发送故障时，就无法发送心跳消息，备节点也就因此无法继续检测到来自Master节点的心跳了，于是调用自身的接管程序，接管主Master节点的IP资源及服务。而当主Master节点恢复时，备Backup节点又会释放主节点故障时自身接管的IP资源及服务，恢复到原来的备用角色</p>
<p>那么什么是VRRP呢？VRRP,全称Virtual Router Redundancy Protocol，中文名为虚拟路由冗余协议，VRRP的出现就是为了解决静态路由的单点故障问题，VRRP是通过一种竞选机制来将路由的任务交给某台VRRP路由器的</p>
<h3 id="集群恢复与故障转移"><a href="#集群恢复与故障转移" class="headerlink" title="集群恢复与故障转移"></a>集群恢复与故障转移</h3><p>RabbitMO镜像队列集群的恢复的解决方案和应用场景<br>√前提:比如两个节点A和B组成一个镜像队列<br>√场景1:A先停,B后停<br>√方案1:该场景下B是 Master,只要先启动B,再启动A即可。或者<br>先启动A,再30秒之内启动B即可恢复镜像队列</p>
<p>√场景2:A、B同时停机<br>√方案2:该场景可能是由于机房掉电等原因造成的,只需在30秒之<br>内连续启动A和B即可恢复镜像</p>
<p>√场景3:A先停,B后停,且A无法恢复<br>√方案3:改场景是1场景的加强版,因为B是 Master,所以等B起来以<br>后,在B节点上调用控制台命令: rabbitmgct<br>forget cluster node A解除与A的 uster关系,再将新的 Slave<br>节点加入B即可重新恢复镜像队列</p>
<p>场景4:A先停,B后停,且B无法恢复<br>ˇ方案4:该场景是场景3的加强版,比较难处理,原因是因为 Master节<br>点无法恢复,早在3.1.x时代之前没有什么好的解决方案,但是现在已经<br>有解决方案了,在3.4.2以后的版本。因为B是主节点,所以直接启动A<br>是不行的,当A无法启动的时候,也就没办法在A节点上调用之前的<br>rabbitmqctl forget cluster node B命令了。新版本中,<br>forget cluster node支持- offline参数（支持线下操作）</p>
<p>√这就意味着允许 rabbitmgctl在理想节点上执行该命令,追使<br>Rabbitmo在未启动Save节点中选择一个节点作为 Master。当在<br>A节点执行 rabbitmqctl forget cluster node- offline B时,<br>RabbitMO会mock一个节点代表A,执行 forget cluster node<br>命令将B剔除 cluster,然后A就可以正常启动了,最后将新的save<br>节点加入A即可重新恢复镜像队列</p>
<p>ˇ场景5:A先停、B后停,且A、B均无法恢复,但是能得到A或B的磁盘文件<br>√方案5:这种场景更加难处理,只能通过恢复数据的方式去尝试恢复,将A或B<br>的数据库文件默认在$ RABBIT HOME/ar/ib/目录中,把它拷贝到新节点的<br>对应 mulia,再将新节点的 hostname改成A或B的 hostname,如果是A节点<br>( Slave)的磁盘文件,则按照场景4处理即可,如果是B节点( Master)的磁<br>盘文件,则按照场景3处理,最后将新的 Slave加入到新节点后完成恢复</p>
<p>√场景6:A先停、B后停,且A、B均无法恢复,且得不到A或B<br>的磁盘文件<br>√嗯,大家可以洗洗睡啦~</p>
<h3 id="延迟插件的作用"><a href="#延迟插件的作用" class="headerlink" title="延迟插件的作用"></a>延迟插件的作用</h3><p>延迟插件作用<br>√延迟队列可以做什么事情?<br>√比如消息的延迟推送、定时任务(消息)的执行。包括一些消息重试策<br>略的配合使用,以及用于业务削峰限流、降级的异步延迟消息机制,都<br>是延迟队列的实际应用场景</p>
<h3 id="互联网Set化架构"><a href="#互联网Set化架构" class="headerlink" title="互联网Set化架构"></a>互联网Set化架构</h3><h4 id="BAT-TMD大厂单元化架构设计衍变之路-一"><a href="#BAT-TMD大厂单元化架构设计衍变之路-一" class="headerlink" title="BAT/TMD大厂单元化架构设计衍变之路(一)"></a>BAT/TMD大厂单元化架构设计衍变之路(一)</h4><p>√随着大型互联网公司业务的多元化发展,就拿滴滴、美团等大厂来讲,如滴<br>滴打车、单车、外卖、酒店、旅行、金融等业务持续高速增长,单个大型分<br>布式体系的集群,通过加机器+集群内部拆分(kv、mq、 MySQL等),虽然<br>具备了一定的可扩展性。但是,随着业务量的进一步增长,整个集群规模逐<br>渐变得巨大,从而一定会在某个点上达到瓶颈,无法满足扩展性需要,并且<br>大集群内核心服务出现问题,会影响全网所有用户。</p>
<h4 id="BAT-TMD大厂单元化架构设计衍变之路-二"><a href="#BAT-TMD大厂单元化架构设计衍变之路-二" class="headerlink" title="BAT/TMD大厂单元化架构设计衍变之路(二)"></a>BAT/TMD大厂单元化架构设计衍变之路(二)</h4><p>以滴滴打车、美团外卖举例来说:<br>打车业务体量巨大,尤其是在早晚高峰期。全年订单量已越10亿。<br>外卖业务体量庞大,目前单量已突破1700W/天,对于如此庞大的单<br>个大型分布式集群,会面临以下问题<br>1、容灾问题<br>2、资源扩展问题<br>3、大集群拆分问题</p>
<h4 id="BAT-TMD大厂单元化架构设计衍变之路-三"><a href="#BAT-TMD大厂单元化架构设计衍变之路-三" class="headerlink" title="BAT/TMD大厂单元化架构设计衍变之路(三)"></a>BAT/TMD大厂单元化架构设计衍变之路(三)</h4><p>√1、容灾问题<br>√核心服务(比如订单服务)挂掉,会影响全网所有用户<br>导致整个业务不可用;<br>数据库主库集中在一个DC,主机房挂掉,会影响全网<br>所有用户,整个业务无法快速切换和恢复;</p>
<h4 id="BAT-TMD大厂单元化架构设计衍变之路-四"><a href="#BAT-TMD大厂单元化架构设计衍变之路-四" class="headerlink" title="BAT/TMD大厂单元化架构设计衍变之路(四)"></a>BAT/TMD大厂单元化架构设计衍变之路(四)</h4><p>ˇ2、资源扩展问题<br>ˇ单DC的资源(机器、网络带宽等)已经没法满足,扩展|DC时,存<br>在跨机房访问时延问题(增加异地机房时,时延问题更加严重)<br>√数据库主库单点,连接数有限,不能支持应用程序的持续扩展;</p>
<h4 id="BAT-TMD大厂单元化架构设计衍变之路-五"><a href="#BAT-TMD大厂单元化架构设计衍变之路-五" class="headerlink" title="BAT/TMD大厂单元化架构设计衍变之路(五)"></a>BAT/TMD大厂单元化架构设计衍变之路(五)</h4><p>√3、大集群拆分问题<br>√核心问题:分布式集群规模扩大后,会相应的带来资源扩展、<br>大集群拆分以及容灾问题。<br>所以出于对业务扩展性以及容灾需求的考虑,我们需要一套从<br>底层架构彻底解决问题的方案,业界主流解决方案<br>√单元化架构方案(阿里、支付宝、饿了么、微信等)</p>
<h4 id="BAT-TMD大厂单元化架构设计衍变之路"><a href="#BAT-TMD大厂单元化架构设计衍变之路" class="headerlink" title="BAT/TMD大厂单元化架构设计衍变之路"></a>BAT/TMD大厂单元化架构设计衍变之路</h4><p>√同城“双活”架构介绍<br>√目前很多大型互联网公司的业务架构可以理解为同城“双活”架构,<br>注意这里的“双活”是加引号的,具体可以这样理解</p>
<h4 id="BAT-TMD大厂单元化架构设计衍变之路-1"><a href="#BAT-TMD大厂单元化架构设计衍变之路-1" class="headerlink" title="BAT/TMD大厂单元化架构设计衍变之路"></a>BAT/TMD大厂单元化架构设计衍变之路</h4><p>√业务层面上已经做到真正的双活(或者多活),分别承担部分流量;<br>√存储层面比如定时任务、缓存、持久层、数据分析等都是主从架构,<br>会有跨机房写;<br>个数据中心故障,可以手动切换流量,部分组件可以自动切换;</p>
<h4 id="BAT-TMD大厂单元化架构设计衍变之路-2"><a href="#BAT-TMD大厂单元化架构设计衍变之路-2" class="headerlink" title="BAT/TMD大厂单元化架构设计衍变之路"></a>BAT/TMD大厂单元化架构设计衍变之路</h4><p>√两地三中心架构介绍<br>√使用灾备的思想,在同城“双活”的基础上,在异地部署一套<br>灾备数据中心,每个中心都具有完备的数据处理能力,只有当<br>主节点故障需要容灾的时候才会紧急启动备用数据中心;</p>
<p><img src="images%5CRabbitMQ%5C19.jpg" alt="19"></p>
<h4 id="BAT-TMD大厂单元化架构设计衍变之路-3"><a href="#BAT-TMD大厂单元化架构设计衍变之路-3" class="headerlink" title="BAT/TMD大厂单元化架构设计衍变之路"></a>BAT/TMD大厂单元化架构设计衍变之路</h4><p>√SET化方案目标<br>√业务:解决业务遇到的扩展性和容灾等需求,支撑业务的高速发展<br>ˇ通用性:架构侧形成统一通用的解决方案,方便各业务线接入使用</p>
<p><img src="images%5CRabbitMQ%5C20.jpg" alt="20"></p>
<h4 id="SET化架构策略"><a href="#SET化架构策略" class="headerlink" title="SET化架构策略"></a>SET化架构策略</h4><p>√流量路由:<br>按照特殊的key(通常为 userid)进行路由,判断某次<br>请求该路由到中心集群还是单元化集群;</p>
<p>√中心集群<br>√未进行单元化改造的服务(通常不在核心交易链路,比如<br>供应链系统)称为中心集群,跟当前架构保持一致。</p>
<p>√单元化集群<br>√每个单元化集群只负责本单元内的流量处理,以实现流量<br>拆分以及故障隔离;<br>√每个单元化集群前期只存储本单元产生的交易数据,后续<br>会做双向数据同步,实现容灾切换需求</p>
<p>√中间件(RPC、KV、MQ等):<br>√RPC:对于SET服务,调用封闭在SET内;对于非SET服务,沿<br>用现有路由逻辑;<br>√KV:支持分SET的数据生产和查询;</p>
<p>√数据同步<br>√全局数据(数据量小且变化不大,比如商家的菜品数据)部署<br>在中心集群,其他单元化集群同步全局数据到本单元化内;<br>未来演变为异地多活架构时,各单元化集群数据需要进行双向<br>同步来实现容灾需要</p>
<p>ˇSE化路由策略及其能力<br>√异地容灾<br>√通过SET化架构的流量调度能力,将SET分别部署在不同<br>地区的数据中心,实现跨地区容灾支持</p>
<p>√高效本地化服务<br>ˇ利用前端位置信息采集和域名解析策略,将流量路由到最近的<br>SET,提供最高效的本地化服务;<br>√比如2O场景天然具有本地生产,本地消费的特点,更加需<br>要SET化支持</p>
<p>√集装箱式扩展<br>√SET的封装性支持更灵活的部署扩展性,比如SET一键创<br>建/下线,SET一键发布等</p>
<p><img src="images%5CRabbitMQ%5C21.jpg" alt="21"></p>
<p><img src="images%5CRabbitMQ%5C22.jpg" alt="22"></p>
<h3 id="SET化重要的原则"><a href="#SET化重要的原则" class="headerlink" title="SET化重要的原则"></a>SET化重要的原则</h3><p>√对业务透明原则:<br>√SET化架构的实现对业务代码透明,业务代码层面不需<br>要关心SET化规则,SET的部署等问题。</p>
<p>√SET化重要的原则<br>√SET切分规则:<br>√理论上,切分规则由业务层面按需定制;<br>√实现上,建议优先选最大的业务维度进行切分;<br>√比如海量用户的O2O业务,按用户位置信息进行切分。此外,<br>接入层、逻辑层和数据层可以有独立的SET切分规则,有利于<br>实现部署和运维成本的最优化。</p>
<p>√SET化重要的原则<br>√部署规范原则<br>√一个SET并不一定只限制在一个机房,也可以跨机房或者<br>跨地区部署;为保证灵活性,单个SET内机器数不宜过多(<br>如不超过1000台物理机)</p>
<p><img src="images%5CRabbitMQ%5C23.jpg" alt="23"></p>
<h4 id="RabbitMO-SET化架构实现"><a href="#RabbitMO-SET化架构实现" class="headerlink" title="RabbitMO-SET化架构实现"></a>RabbitMO-SET化架构实现</h4><p>√使用 RabbitMQ异步消息通信插件 Federation安装与配置<br>v rabbitmq-plugins enable rabbitmq federation<br>v rabbitmq-plugins enable rabbitmq_federation management<br>√备注:当你在一个 cluste中使用 federation插件,所有在集群中的<br>nodes都需要安装 federation插件</p>
<p>使用 RabbitS通信插件 Federation:<br>v Federation插件是一个在不需要 cluster,而 brokers之间传输消<br>息的高性能插件。<br>Federation插件可以在 brokers或者 cluster之间传输消息,链接<br>的双方可以使用不同的 users和 virtual hosts、或者双方的<br>rabbitry和 erlang版本不一致, federation插件使用AMQP协议<br>通信,可以接受不连续的传输。<br>SET化配置规则:<br>第一, Federation Exchanges,可以看成 Downstream(82节点)从 Upstream<br>81节点)主动拉取消息,但并不是拉取所有消息,必须是在 Downstream上已<br>经明确定义 Bindings关系的 Exchange,也就是有实际的物理 Queue来接收消息<br>,才会从 Upstream拉取消息到 Downstream。使用AMQP协议实施代理间通信<br>Downstream会将绑定关系组合在一起,绑定/解除绑定命令将发送到 Upstream<br>交换机</p>
<p>√第二,经过配置后, Upstream节点已经可以把消息直接通过 Federation<br>Exchanges路由给我们的 Downstream节点,然后进行消费<br>也就是说可以实现消息的转发,接下来也可以在 Upstream添加具体的队列去<br>进行消费 Federation Exchanges里的消息,我们一条消息分别发到了2个<br>Rabbits集群并且消费,这样我们可以实现SET化的关键要素,就是集群间<br>的消息同步了</p>
<p>√第三,可以根据自己的业务规则去规划不同的集群去监听不同的消息<br>队列,从而达到SET化的手段,保障了性能、可靠性、数据一致性。</p>
<h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><p>基础组件封装设计-延迟消息发送<br>基础组件封装设计-顺序消息发送<br>基础组件封装设计-事务消息发送<br>消息幂等性保障-消息路由规则架构设计</p>
<img src="images\RabbitMQ\24.jpg" alt="24">



<h4 id="MQ组件实现功能点"><a href="#MQ组件实现功能点" class="headerlink" title="MQ组件实现功能点(-)"></a>MQ组件实现功能点(-)</h4><p>√支持消息高性能的序列化转换、异步化发送消息<br>√支持消息生产实例与消费实例的链接池化缓存化提升性能<br>√支持可靠性投递消息,保障消息的100%不丢失<br>√支持消费端的幂等操作,避免消费端重复消费的问题</p>
<h4 id="MQ组件实现功能点-二"><a href="#MQ组件实现功能点-二" class="headerlink" title="MQ组件实现功能点(二)"></a>MQ组件实现功能点(二)</h4><p>支持迅速消息发送模式,在一些日志收集/统计分析等需求下可以保证<br>高性能,超高吞吐量。<br>支持延迟消息模式,消息可以延迟发送,指定延迟时间,用于某些延<br>迟检查、服务限流场景<br>支持事务消息,且100%保障可靠性投递,在金融行业单笔大金额操作<br>时会有此类需求</p>
<h4 id="MQ组件实现功能点-三"><a href="#MQ组件实现功能点-三" class="headerlink" title="MQ组件实现功能点(三)"></a>MQ组件实现功能点(三)</h4><p>√支持顺序消息,保证消息送达消费端的前后顺序,例如下订单等复合性操作<br>√支持消息补偿,重试,以及快速定位异常/失败消息<br>√支持集群消息负载均衡,保障消息落到具体SE「集群的负载均衡<br>√支持消息路由策略,指定某些消息路由到指定的SET集群</p>
<img src="images\RabbitMQ\25.png" alt="25">

<p><img src="images%5CRabbitMQ%5C26.png" alt="26"></p>
<h4 id="消息发送模式-批量消息发送-一"><a href="#消息发送模式-批量消息发送-一" class="headerlink" title="消息发送模式-批量消息发送(一)"></a>消息发送模式-批量消息发送(一)</h4><p>√批量消息是指我们把消息放到一个集合里统一进行提交,这种方案设计思路<br>是期望消息在一个会话里,比如投掷到 Ithreadlocal里的集合,然后拥有相同<br>会话D,并且带有这次提交消息的SzE等相关属性,最重要的一点是要把这<br>批消息进行合并。对于 Channe而言,就是发送一次消息。这种方式也是<br>希望消费端在消费的时候,可以进行批量化的消费,针对于某一个原子业务<br>的操作去处理,但是不保障可靠性,需要进行补偿机制。</p>
<p><img src="images%5CRabbitMQ%5C27.png" alt="27"></p>
<h4 id="消息发送模式-延迟消息发送"><a href="#消息发送模式-延迟消息发送" class="headerlink" title="消息发送模式-延迟消息发送"></a>消息发送模式-延迟消息发送</h4><p>ˇ延迟消息相对简单,就是我们在 Message封装的时候添加 delay Time属<br>性即可,使得我们的消息可以进行延迟发送,根据具体的业务场景也可<br>以很好的使用得到!</p>
<p>√场景举例:<br>√比如你在电商平台买到的商品签收后,不点击确认支付,那么系统自动<br>会在7天(一定时间)去进行支付操作<br>√还有一些自动超时作废的场景,你的优惠券有使用时间限制,也可<br>以用延迟消息机制</p>
<h4 id="消息发送模式-顺序消息-一"><a href="#消息发送模式-顺序消息-一" class="headerlink" title="消息发送模式-顺序消息(一)"></a>消息发送模式-顺序消息(一)</h4><p>√顺序消息,比较类似于批量消息的实现机制,但是也有些不同。<br>√我们要保障以下几点<br>√1发送的顺序消息,必须保障消息投递到同一个队列,且这个消费者只能有一个<br>(独占模式)<br>√2然后需要统一提交(可能是合并成一个大消息也可能是拆分为多个消息),并且<br>所有消息的会话|D一致<br>√3添加消息属性:顺序标记的序号、和本次顺序消息的SzE属性,进行落库操作</p>
<h4 id="消息发送模式-顺序消息-二"><a href="#消息发送模式-顺序消息-二" class="headerlink" title="消息发送模式-顺序消息(二)"></a>消息发送模式-顺序消息(二)</h4><p>√4并行进行发送给自身的延迟消息(注意带上关键属性:会话|D、SZE)进<br>行后续处理消费<br>√5当收到延迟消息后,根据会话D、SZE抽取数据库数据进行处理即可<br>√6定时轮训补偿机制,对于异常情况<br>备注:比如生产端消息没有完全投递成功、或者消費端落库异常<br>导致消费端落库后缺少消息条目的情况)</p>
<p><img src="images%5CRabbitMQ%5C28.png" alt="28"></p>
<h4 id="消息发送模式-事务消息发送-一"><a href="#消息发送模式-事务消息发送-一" class="headerlink" title="消息发送模式-事务消息发送(一)"></a>消息发送模式-事务消息发送(一)</h4><p>√事务消息,相对使用比较少见,但是本神在早期做互联网金融行业<br>中,面对单笔大额的现金流交易时遇到过:比如单笔转账超过一个<br>上限的时候,我们就希望这个消息优先级最高,并且可靠性要求达<br>到100%,当然我们的系统和银行端系统都要兼顾才行,所以也会有<br>些补偿机制,主动发起银行端查询指令机制等。</p>
<h4 id="消息发送模式-事务消息发送-二"><a href="#消息发送模式-事务消息发送-二" class="headerlink" title="消息发送模式-事务消息发送(二)"></a>消息发送模式-事务消息发送(二)</h4><p>为了保障性能的同时,也支持事务。我们井没有选择传统的 RabbitS<br>事务和 Spring集成的机制,因为在性能测试的过程中,效果并不理想<br>非常消耗系统资源目会出现阻塞等情况,在高峰期也是一定程度上影<br>响MQ集群的性能</p>
<h4 id="消息发送模式-事务消息发送-三"><a href="#消息发送模式-事务消息发送-三" class="headerlink" title="消息发送模式-事务消息发送(三)"></a>消息发送模式-事务消息发送(三)</h4><p>√解决方案<br>√我们采用类似可靠性投递的机制,也就是补偿机制<br>√但是我们的数据源必须是同一个,也就是业务操作DB1数据库和消息记录DB2<br>数据库使用同一个数据源<br>√然后利用重写 Spring Data Source TransactionManager,在本地事务提交的<br>时候进行发送消息,但是也有可能事务提交成功但是消息发送失败,这个时候<br>就需要进行补偿了。</p>
<p><img src="images%5CRabbitMQ%5C29.png" alt="29"></p>
<p><img src="images%5CRabbitMQ%5C30.png" alt="30"></p>
<h4 id="消息的幂等性的必要性"><a href="#消息的幂等性的必要性" class="headerlink" title="消息的幂等性的必要性"></a>消息的幂等性的必要性</h4><p>√保障消息的幂等性,这也是我们在使用MQ中至关重要的环节<br>√可能导致消息出现非幂等的原因<br>√1可靠性消息投递机制<br>ˇ2 MQ Broker服务与消费端传输消息的过程中的网络抖动<br>√3消费端故障或异常</p>
<p><img src="images%5CRabbitMQ%5C31.png" alt="31"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/15/学习文档/MQ/RabbitMQ/" data-id="ck46kswf1000764sso7cay5v1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-学习文档/MQ/KAFKA" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/15/学习文档/MQ/KAFKA/" class="article-date">
  <time datetime="2019-12-15T05:32:17.258Z" itemprop="datePublished">2019-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="G:%5C%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3%5CMQ%5Cimages%5CRocketMQ%5C1572074916984.png" alt="1572074916984"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/15/学习文档/MQ/KAFKA/" data-id="ck46kswe9000664ssho14wsj9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/12/15/raids/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/12/15/学习文档/项目管理/github/github学习/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/12/15/学习文档/项目管理/git/idea-git配置/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/12/15/学习文档/项目管理/git/git学习文档/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/12/15/学习文档/框架/SOA架构和微服务架构的区别/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>